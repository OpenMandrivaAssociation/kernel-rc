diff --git a/Documentation/devicetree/bindings/serial/8250.yaml b/Documentation/devicetree/bindings/serial/8250.yaml
index e46bee8d25bf0..c6bc27709bf72 100644
--- a/Documentation/devicetree/bindings/serial/8250.yaml
+++ b/Documentation/devicetree/bindings/serial/8250.yaml
@@ -49,24 +49,6 @@ allOf:
         - required: [ clock-frequency ]
         - required: [ clocks ]
 
-  - if:
-      properties:
-        compatible:
-          contains:
-            const: nxp,lpc1850-uart
-    then:
-      properties:
-        clock-names:
-          items:
-            - const: uartclk
-            - const: reg
-    else:
-      properties:
-        clock-names:
-          items:
-            - const: core
-            - const: bus
-
 properties:
   compatible:
     oneOf:
@@ -160,22 +142,9 @@ properties:
 
   clock-names:
     minItems: 1
-    maxItems: 2
-    oneOf:
-      - items:
-          - const: core
-          - const: bus
-      - items:
-          - const: uartclk
-          - const: reg
-
-  dmas:
-    minItems: 1
-    maxItems: 4
-
-  dma-names:
-    minItems: 1
-    maxItems: 4
+    items:
+      - const: core
+      - const: bus
 
   resets:
     maxItems: 1
@@ -268,13 +237,9 @@ if:
   properties:
     compatible:
       contains:
-        enum:
-          - spacemit,k1-uart
-          - nxp,lpc1850-uart
+        const: spacemit,k1-uart
 then:
-  required:
-    - clocks
-    - clock-names
+  required: [clock-names]
   properties:
     clocks:
       minItems: 2
diff --git a/Documentation/devicetree/bindings/serial/mediatek,uart.yaml b/Documentation/devicetree/bindings/serial/mediatek,uart.yaml
index 5bd8a8853ae0d..c55d9a0efa190 100644
--- a/Documentation/devicetree/bindings/serial/mediatek,uart.yaml
+++ b/Documentation/devicetree/bindings/serial/mediatek,uart.yaml
@@ -25,7 +25,6 @@ properties:
           - enum:
               - mediatek,mt2701-uart
               - mediatek,mt2712-uart
-              - mediatek,mt6572-uart
               - mediatek,mt6580-uart
               - mediatek,mt6582-uart
               - mediatek,mt6589-uart
diff --git a/Documentation/devicetree/bindings/serial/qcom,sa8255p-geni-uart.yaml b/Documentation/devicetree/bindings/serial/qcom,sa8255p-geni-uart.yaml
deleted file mode 100644
index c8f01923cb25d..0000000000000
--- a/Documentation/devicetree/bindings/serial/qcom,sa8255p-geni-uart.yaml
+++ /dev/null
@@ -1,69 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/serial/qcom,sa8255p-geni-uart.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: Qualcomm Geni based QUP UART interface
-
-maintainers:
-  - Praveen Talari <quic_ptalari@quicinc.com>
-
-allOf:
-  - $ref: /schemas/serial/serial.yaml#
-
-properties:
-  compatible:
-    enum:
-      - qcom,sa8255p-geni-uart
-      - qcom,sa8255p-geni-debug-uart
-
-  reg:
-    maxItems: 1
-
-  interrupts:
-    minItems: 1
-    items:
-      - description: UART core irq
-      - description: Wakeup irq (RX GPIO)
-
-  interrupt-names:
-    description:
-      The UART interrupt and optionally the RX in-band wakeup interrupt
-      as not all UART instances have a wakeup-capable interrupt routed
-      via the PDC.
-    minItems: 1
-    items:
-      - const: uart
-      - const: wakeup
-
-  power-domains:
-    minItems: 2
-    maxItems: 2
-
-  power-domain-names:
-    items:
-      - const: power
-      - const: perf
-
-required:
-  - compatible
-  - reg
-  - interrupts
-  - power-domains
-  - power-domain-names
-
-unevaluatedProperties: false
-
-examples:
-  - |
-    #include <dt-bindings/interrupt-controller/arm-gic.h>
-
-    serial@990000 {
-        compatible = "qcom,sa8255p-geni-uart";
-        reg = <0x990000 0x4000>;
-        interrupts = <GIC_SPI 531 IRQ_TYPE_LEVEL_HIGH>;
-        power-domains = <&scmi0_pd 0>, <&scmi0_dvfs 0>;
-        power-domain-names = "power", "perf";
-    };
-...
diff --git a/Documentation/devicetree/bindings/serial/renesas,hscif.yaml b/Documentation/devicetree/bindings/serial/renesas,hscif.yaml
index 4b3f98a46cd9d..9480ed30915c9 100644
--- a/Documentation/devicetree/bindings/serial/renesas,hscif.yaml
+++ b/Documentation/devicetree/bindings/serial/renesas,hscif.yaml
@@ -63,12 +63,6 @@ properties:
           - const: renesas,rcar-gen4-hscif # R-Car Gen4
           - const: renesas,hscif           # generic HSCIF compatible UART
 
-      - items:
-          - enum:
-              - renesas,hscif-r8a78000     # R-Car X5H
-          - const: renesas,rcar-gen5-hscif # R-Car Gen5
-          - const: renesas,hscif           # generic HSCIF compatible UART
-
   reg:
     maxItems: 1
 
@@ -126,7 +120,6 @@ if:
           - renesas,rcar-gen2-hscif
           - renesas,rcar-gen3-hscif
           - renesas,rcar-gen4-hscif
-          - renesas,rcar-gen5-hscif
 then:
   required:
     - resets
diff --git a/Documentation/devicetree/bindings/serial/renesas,rsci.yaml b/Documentation/devicetree/bindings/serial/renesas,rsci.yaml
index f50d8e02f4764..ea879db5f4850 100644
--- a/Documentation/devicetree/bindings/serial/renesas,rsci.yaml
+++ b/Documentation/devicetree/bindings/serial/renesas,rsci.yaml
@@ -8,20 +8,14 @@ title: Renesas RSCI Serial Communication Interface
 
 maintainers:
   - Geert Uytterhoeven <geert+renesas@glider.be>
-  - Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>
+  - Thierry Bultel <thierry.bultel.yh@bp.renesas.com>
 
 allOf:
   - $ref: serial.yaml#
 
 properties:
   compatible:
-    oneOf:
-      - items:
-          - const: renesas,r9a09g087-rsci # RZ/N2H
-          - const: renesas,r9a09g077-rsci # RZ/T2H
-
-      - items:
-          - const: renesas,r9a09g077-rsci # RZ/T2H
+    const: renesas,r9a09g077-rsci      # RZ/T2H
 
   reg:
     maxItems: 1
@@ -41,15 +35,10 @@ properties:
       - const: tei
 
   clocks:
-    minItems: 2
-    maxItems: 3
+    maxItems: 1
 
   clock-names:
-    minItems: 2
-    items:
-      - const: operation
-      - const: bus
-      - const: sck # optional external clock input
+    const: fck # UART functional clock
 
   power-domains:
     maxItems: 1
@@ -71,6 +60,10 @@ examples:
     #include <dt-bindings/interrupt-controller/arm-gic.h>
     #include <dt-bindings/clock/renesas-cpg-mssr.h>
 
+    aliases {
+        serial0 = &sci0;
+    };
+
     sci0: serial@80005000 {
         compatible = "renesas,r9a09g077-rsci";
         reg = <0x80005000 0x400>;
@@ -79,7 +72,7 @@ examples:
                      <GIC_SPI 592 IRQ_TYPE_EDGE_RISING>,
                      <GIC_SPI 593 IRQ_TYPE_LEVEL_HIGH>;
         interrupt-names = "eri", "rxi", "txi", "tei";
-        clocks = <&cpg CPG_MOD 8>, <&cpg CPG_CORE 13>;
-        clock-names = "operation", "bus";
+        clocks = <&cpg CPG_MOD 108>;
+        clock-names = "fck";
         power-domains = <&cpg>;
     };
diff --git a/Documentation/devicetree/bindings/serial/renesas,scif.yaml b/Documentation/devicetree/bindings/serial/renesas,scif.yaml
index e925cd4c3ac8a..8e82999e6acb5 100644
--- a/Documentation/devicetree/bindings/serial/renesas,scif.yaml
+++ b/Documentation/devicetree/bindings/serial/renesas,scif.yaml
@@ -70,12 +70,6 @@ properties:
           - const: renesas,rcar-gen4-scif # R-Car Gen4
           - const: renesas,scif           # generic SCIF compatible UART
 
-      - items:
-          - enum:
-              - renesas,scif-r8a78000     # R-Car X5H
-          - const: renesas,rcar-gen5-scif # R-Car Gen5
-          - const: renesas,scif           # generic SCIF compatible UART
-
       - items:
           - enum:
               - renesas,scif-r9a07g044      # RZ/G2{L,LC}
@@ -92,7 +86,6 @@ properties:
       - items:
           - enum:
               - renesas,scif-r9a09g047      # RZ/G3E
-              - renesas,scif-r9a09g056      # RZ/V2N
           - const: renesas,scif-r9a09g057   # RZ/V2H fallback
 
   reg:
@@ -181,7 +174,6 @@ allOf:
               - renesas,rcar-gen2-scif
               - renesas,rcar-gen3-scif
               - renesas,rcar-gen4-scif
-              - renesas,rcar-gen5-scif
               - renesas,scif-r9a07g044
               - renesas,scif-r9a09g057
     then:
diff --git a/Documentation/devicetree/bindings/serial/samsung_uart.yaml b/Documentation/devicetree/bindings/serial/samsung_uart.yaml
index 1a1f991d53649..83d9986d8e98a 100644
--- a/Documentation/devicetree/bindings/serial/samsung_uart.yaml
+++ b/Documentation/devicetree/bindings/serial/samsung_uart.yaml
@@ -28,10 +28,6 @@ properties:
           - samsung,exynos5433-uart
           - samsung,exynos850-uart
           - samsung,exynos8895-uart
-      - items:
-          - enum:
-              - samsung,exynos2200-uart
-          - const: google,gs101-uart
       - items:
           - enum:
               - samsung,exynos7-uart
diff --git a/Documentation/devicetree/bindings/serial/snps-dw-apb-uart.yaml b/Documentation/devicetree/bindings/serial/snps-dw-apb-uart.yaml
index cb9da6c97afcf..8f1b7f704c5bc 100644
--- a/Documentation/devicetree/bindings/serial/snps-dw-apb-uart.yaml
+++ b/Documentation/devicetree/bindings/serial/snps-dw-apb-uart.yaml
@@ -108,9 +108,6 @@ properties:
       parameter. Define this if your UART does not implement the busy functionality.
     type: boolean
 
-  power-domains:
-    maxItems: 1
-
   resets:
     minItems: 1
     maxItems: 2
diff --git a/Documentation/devicetree/bindings/soc/qcom/qcom,sa8255p-geni-se-qup.yaml b/Documentation/devicetree/bindings/soc/qcom/qcom,sa8255p-geni-se-qup.yaml
deleted file mode 100644
index 352af3426d344..0000000000000
--- a/Documentation/devicetree/bindings/soc/qcom/qcom,sa8255p-geni-se-qup.yaml
+++ /dev/null
@@ -1,107 +0,0 @@
-# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
-%YAML 1.2
----
-$id: http://devicetree.org/schemas/soc/qcom/qcom,sa8255p-geni-se-qup.yaml#
-$schema: http://devicetree.org/meta-schemas/core.yaml#
-
-title: GENI Serial Engine QUP Wrapper Controller
-
-maintainers:
-  - Praveen Talari <quic_ptalari@quicinc.com>
-
-description:
-  Generic Interface (GENI) based Qualcomm Universal Peripheral (QUP) wrapper
-  is a programmable module for supporting a wide range of serial interfaces
-  like UART, SPI, I2C, I3C, etc. A single QUP module can provide up to 8 Serial
-  Interfaces, using its internal Serial Engines. The GENI Serial Engine QUP
-  Wrapper controller is modeled as a node with zero or more child nodes each
-  representing a serial engine.
-
-properties:
-  compatible:
-    const: qcom,sa8255p-geni-se-qup
-
-  reg:
-    description: QUP wrapper common register address and length.
-    maxItems: 1
-
-  "#address-cells":
-    const: 2
-
-  "#size-cells":
-    const: 2
-
-  ranges: true
-
-  iommus:
-    maxItems: 1
-
-  dma-coherent: true
-
-patternProperties:
-  "spi@[0-9a-f]+$":
-    type: object
-    description: GENI serial engine based SPI controller. SPI in master mode
-                 supports up to 50MHz, up to four chip selects, programmable
-                 data path from 4 bits to 32 bits and numerous protocol
-                 variants.
-    additionalProperties: true
-
-    properties:
-      compatible:
-        const: qcom,sa8255p-geni-spi
-
-  "i2c@[0-9a-f]+$":
-    type: object
-    description: GENI serial engine based I2C controller.
-    additionalProperties: true
-
-    properties:
-      compatible:
-        const: qcom,sa8255p-geni-i2c
-
-  "serial@[0-9a-f]+$":
-    type: object
-    description: GENI Serial Engine based UART Controller.
-    additionalProperties: true
-
-    properties:
-      compatible:
-        enum:
-          - qcom,sa8255p-geni-uart
-          - qcom,sa8255p-geni-debug-uart
-
-required:
-  - compatible
-  - reg
-  - "#address-cells"
-  - "#size-cells"
-  - ranges
-
-additionalProperties: false
-
-examples:
-  - |
-    #include <dt-bindings/interrupt-controller/arm-gic.h>
-
-    soc {
-        #address-cells = <2>;
-        #size-cells = <2>;
-
-        geniqup@9c0000 {
-            compatible = "qcom,sa8255p-geni-se-qup";
-            reg = <0 0x9c0000 0 0x6000>;
-            #address-cells = <2>;
-            #size-cells = <2>;
-            ranges;
-
-            serial@990000 {
-                compatible = "qcom,sa8255p-geni-uart";
-                reg = <0 0x990000 0 0x4000>;
-                interrupts = <GIC_SPI 531 IRQ_TYPE_LEVEL_HIGH>;
-                power-domains = <&scmi0_pd 0>, <&scmi0_dvfs 0>;
-                power-domain-names = "power", "perf";
-            };
-        };
-    };
-...
diff --git a/Documentation/driver-api/serial/driver.rst b/Documentation/driver-api/serial/driver.rst
index c1db6a1a67c4e..fa1ebfcd4472e 100644
--- a/Documentation/driver-api/serial/driver.rst
+++ b/Documentation/driver-api/serial/driver.rst
@@ -24,8 +24,9 @@ console support.
 Console Support
 ---------------
 
-The serial core provides a few helper functions.  This includes
-decoding command line arguments (uart_parse_options()).
+The serial core provides a few helper functions.  This includes identifying
+the correct port structure (via uart_get_console()) and decoding command line
+arguments (uart_parse_options()).
 
 There is also a helper function (uart_console_write()) which performs a
 character by character write, translating newlines to CRLF sequences.
@@ -75,7 +76,7 @@ Other functions
            uart_add_one_port uart_remove_one_port uart_console_write
            uart_parse_earlycon uart_parse_options uart_set_options
            uart_get_lsr_info uart_handle_dcd_change uart_handle_cts_change
-           uart_try_toggle_sysrq
+           uart_try_toggle_sysrq uart_get_console
 
 .. kernel-doc:: include/linux/serial_core.h
    :identifiers: uart_port_tx_limited uart_port_tx
diff --git a/Documentation/driver-api/tty/tty_port.rst b/Documentation/driver-api/tty/tty_port.rst
index 504a353f26825..5cb90e954fcf7 100644
--- a/Documentation/driver-api/tty/tty_port.rst
+++ b/Documentation/driver-api/tty/tty_port.rst
@@ -42,10 +42,9 @@ TTY Refcounting
 TTY Helpers
 -----------
 
-.. kernel-doc::  include/linux/tty_port.h
-   :identifiers: tty_port_tty_hangup tty_port_tty_vhangup
 .. kernel-doc::  drivers/tty/tty_port.c
-   :identifiers: tty_port_tty_wakeup
+   :identifiers: tty_port_tty_hangup tty_port_tty_wakeup
+
 
 Modem Signals
 -------------
diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 242d18e750b0a..0147130dc34e3 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -16,10 +16,12 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/seq_file.h>
+#include <linux/tty.h>
 #include <linux/clocksource.h>
 #include <linux/console.h>
 #include <linux/rtc.h>
 #include <linux/init.h>
+#include <linux/vt_kern.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/zorro.h>
diff --git a/arch/m68k/apollo/config.c b/arch/m68k/apollo/config.c
index e324c5f671de4..e161ecd760358 100644
--- a/arch/m68k/apollo/config.c
+++ b/arch/m68k/apollo/config.c
@@ -3,7 +3,9 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/tty.h>
 #include <linux/rtc.h>
+#include <linux/vt_kern.h>
 #include <linux/interrupt.h>
 
 #include <asm/setup.h>
diff --git a/arch/m68k/atari/config.c b/arch/m68k/atari/config.c
index ee2d061efb2a8..b48a0606a0006 100644
--- a/arch/m68k/atari/config.c
+++ b/arch/m68k/atari/config.c
@@ -33,6 +33,7 @@
 #include <linux/ioport.h>
 #include <linux/platform_device.h>
 #include <linux/usb/isp116x.h>
+#include <linux/vt_kern.h>
 #include <linux/module.h>
 
 #include <asm/bootinfo.h>
diff --git a/arch/m68k/mac/config.c b/arch/m68k/mac/config.c
index c0033f885ed4f..d26c7f4f8c360 100644
--- a/arch/m68k/mac/config.c
+++ b/arch/m68k/mac/config.c
@@ -15,6 +15,7 @@
 #include <linux/reboot.h>
 #include <linux/types.h>
 #include <linux/mm.h>
+#include <linux/tty.h>
 #include <linux/console.h>
 #include <linux/interrupt.h>
 /* keyb */
@@ -22,6 +23,7 @@
 #include <linux/delay.h>
 /* keyb */
 #include <linux/init.h>
+#include <linux/vt_kern.h>
 #include <linux/platform_device.h>
 #include <linux/ata_platform.h>
 #include <linux/adb.h>
diff --git a/arch/m68k/q40/config.c b/arch/m68k/q40/config.c
index 5a42586976227..de7870ad2a306 100644
--- a/arch/m68k/q40/config.c
+++ b/arch/m68k/q40/config.c
@@ -13,12 +13,14 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/tty.h>
 #include <linux/console.h>
 #include <linux/linkage.h>
 #include <linux/init.h>
 #include <linux/major.h>
 #include <linux/serial_reg.h>
 #include <linux/rtc.h>
+#include <linux/vt_kern.h>
 #include <linux/bcd.h>
 #include <linux/platform_device.h>
 
diff --git a/arch/powerpc/kernel/legacy_serial.c b/arch/powerpc/kernel/legacy_serial.c
index ae1906bfe8a57..1da2f6e7d2a13 100644
--- a/arch/powerpc/kernel/legacy_serial.c
+++ b/arch/powerpc/kernel/legacy_serial.c
@@ -54,10 +54,9 @@ static int legacy_serial_console = -1;
 static const upf_t legacy_port_flags = UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
 	UPF_SHARE_IRQ | UPF_FIXED_PORT;
 
-static u32 tsi_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int tsi_serial_in(struct uart_port *p, int offset)
 {
-	u32 tmp;
-
+	unsigned int tmp;
 	offset = offset << p->regshift;
 	if (offset == UART_IIR) {
 		tmp = readl(p->membase + (UART_IIR & ~3));
@@ -66,7 +65,7 @@ static u32 tsi_serial_in(struct uart_port *p, unsigned int offset)
 		return readb(p->membase + offset);
 }
 
-static void tsi_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void tsi_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = offset << p->regshift;
 	if (!((offset == UART_IER) && (value & UART_IER_UUE)))
@@ -78,8 +77,6 @@ static int __init add_legacy_port(struct device_node *np, int want_index,
 				  phys_addr_t taddr, unsigned long irq,
 				  upf_t flags, int irq_check_parent)
 {
-	struct plat_serial8250_port *legacy_port;
-	struct legacy_serial_info *legacy_info;
 	const __be32 *clk, *spd, *rs;
 	u32 clock = BASE_BAUD * 16;
 	u32 shift = 0;
@@ -113,17 +110,16 @@ static int __init add_legacy_port(struct device_node *np, int want_index,
 	if (index >= legacy_serial_count)
 		legacy_serial_count = index + 1;
 
-	legacy_port = &legacy_serial_ports[index];
-	legacy_info = &legacy_serial_infos[index];
-
 	/* Check if there is a port who already claimed our slot */
-	if (legacy_info->np != NULL) {
+	if (legacy_serial_infos[index].np != NULL) {
 		/* if we still have some room, move it, else override */
 		if (legacy_serial_count < MAX_LEGACY_SERIAL_PORTS) {
 			printk(KERN_DEBUG "Moved legacy port %d -> %d\n",
 			       index, legacy_serial_count);
-			legacy_serial_ports[legacy_serial_count] = *legacy_port;
-			legacy_serial_infos[legacy_serial_count] = *legacy_info;
+			legacy_serial_ports[legacy_serial_count] =
+				legacy_serial_ports[index];
+			legacy_serial_infos[legacy_serial_count] =
+				legacy_serial_infos[index];
 			legacy_serial_count++;
 		} else {
 			printk(KERN_DEBUG "Replacing legacy port %d\n", index);
@@ -131,32 +127,36 @@ static int __init add_legacy_port(struct device_node *np, int want_index,
 	}
 
 	/* Now fill the entry */
-	memset(legacy_port, 0, sizeof(*legacy_port));
+	memset(&legacy_serial_ports[index], 0,
+	       sizeof(struct plat_serial8250_port));
 	if (iotype == UPIO_PORT)
-		legacy_port->iobase = base;
+		legacy_serial_ports[index].iobase = base;
 	else
-		legacy_port->mapbase = base;
-
-	legacy_port->iotype = iotype;
-	legacy_port->uartclk = clock;
-	legacy_port->irq = irq;
-	legacy_port->flags = flags;
-	legacy_port->regshift = shift;
-	legacy_info->taddr = taddr;
-	legacy_info->np = of_node_get(np);
-	legacy_info->clock = clock;
-	legacy_info->speed = spd ? be32_to_cpup(spd) : 0;
-	legacy_info->irq_check_parent = irq_check_parent;
+		legacy_serial_ports[index].mapbase = base;
+
+	legacy_serial_ports[index].iotype = iotype;
+	legacy_serial_ports[index].uartclk = clock;
+	legacy_serial_ports[index].irq = irq;
+	legacy_serial_ports[index].flags = flags;
+	legacy_serial_ports[index].regshift = shift;
+	legacy_serial_infos[index].taddr = taddr;
+	legacy_serial_infos[index].np = of_node_get(np);
+	legacy_serial_infos[index].clock = clock;
+	legacy_serial_infos[index].speed = spd ? be32_to_cpup(spd) : 0;
+	legacy_serial_infos[index].irq_check_parent = irq_check_parent;
 
 	if (iotype == UPIO_TSI) {
-		legacy_port->serial_in = tsi_serial_in;
-		legacy_port->serial_out = tsi_serial_out;
+		legacy_serial_ports[index].serial_in = tsi_serial_in;
+		legacy_serial_ports[index].serial_out = tsi_serial_out;
 	}
 
-	printk(KERN_DEBUG "Found legacy serial port %d for %pOF\n", index, np);
-	printk(KERN_DEBUG "  %s=%pa, taddr=%pa, irq=%lx, clk=%d, speed=%d\n",
+	printk(KERN_DEBUG "Found legacy serial port %d for %pOF\n",
+	       index, np);
+	printk(KERN_DEBUG "  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\n",
 	       (iotype == UPIO_PORT) ? "port" : "mem",
-	       &base, &taddr, irq, legacy_port->uartclk, legacy_info->speed);
+	       (unsigned long long)base, (unsigned long long)taddr, irq,
+	       legacy_serial_ports[index].uartclk,
+	       legacy_serial_infos[index].speed);
 
 	return index;
 }
diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index eb092f293113e..e119ced05d103 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -28,11 +28,13 @@
 #include <linux/ptrace.h>
 #include <linux/export.h>
 #include <linux/user.h>
+#include <linux/tty.h>
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/ioport.h>
 #include <linux/major.h>
 #include <linux/initrd.h>
+#include <linux/vt_kern.h>
 #include <linux/console.h>
 #include <linux/pci.h>
 #include <linux/adb.h>
diff --git a/arch/x86/include/asm/ce4100.h b/arch/x86/include/asm/ce4100.h
index e1f965bb1e312..2930f560d7f35 100644
--- a/arch/x86/include/asm/ce4100.h
+++ b/arch/x86/include/asm/ce4100.h
@@ -4,10 +4,4 @@
 
 int ce4100_pci_init(void);
 
-#ifdef CONFIG_SERIAL_8250
-void __init sdv_serial_fixup(void);
-#else
-static inline void sdv_serial_fixup(void) {};
-#endif
-
 #endif
diff --git a/arch/x86/platform/ce4100/ce4100.c b/arch/x86/platform/ce4100/ce4100.c
index aaa7017416f7b..f8126821a94d7 100644
--- a/arch/x86/platform/ce4100/ce4100.c
+++ b/arch/x86/platform/ce4100/ce4100.c
@@ -5,12 +5,19 @@
  * (C) Copyright 2010 Intel Corporation
  */
 #include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/irq.h>
 #include <linux/reboot.h>
+#include <linux/serial_reg.h>
+#include <linux/serial_8250.h>
 
 #include <asm/ce4100.h>
 #include <asm/prom.h>
 #include <asm/setup.h>
+#include <asm/i8259.h>
 #include <asm/io.h>
+#include <asm/io_apic.h>
+#include <asm/emergency-restart.h>
 
 /*
  * The CE4100 platform has an internal 8051 Microcontroller which is
@@ -24,6 +31,94 @@ static void ce4100_power_off(void)
 	outb(0x4, 0xcf9);
 }
 
+#ifdef CONFIG_SERIAL_8250
+
+static unsigned int mem_serial_in(struct uart_port *p, int offset)
+{
+	offset = offset << p->regshift;
+	return readl(p->membase + offset);
+}
+
+/*
+ * The UART Tx interrupts are not set under some conditions and therefore serial
+ * transmission hangs. This is a silicon issue and has not been root caused. The
+ * workaround for this silicon issue checks UART_LSR_THRE bit and UART_LSR_TEMT
+ * bit of LSR register in interrupt handler to see whether at least one of these
+ * two bits is set, if so then process the transmit request. If this workaround
+ * is not applied, then the serial transmission may hang. This workaround is for
+ * errata number 9 in Errata - B step.
+*/
+
+static unsigned int ce4100_mem_serial_in(struct uart_port *p, int offset)
+{
+	unsigned int ret, ier, lsr;
+
+	if (offset == UART_IIR) {
+		offset = offset << p->regshift;
+		ret = readl(p->membase + offset);
+		if (ret & UART_IIR_NO_INT) {
+			/* see if the TX interrupt should have really set */
+			ier = mem_serial_in(p, UART_IER);
+			/* see if the UART's XMIT interrupt is enabled */
+			if (ier & UART_IER_THRI) {
+				lsr = mem_serial_in(p, UART_LSR);
+				/* now check to see if the UART should be
+				   generating an interrupt (but isn't) */
+				if (lsr & (UART_LSR_THRE | UART_LSR_TEMT))
+					ret &= ~UART_IIR_NO_INT;
+			}
+		}
+	} else
+		ret =  mem_serial_in(p, offset);
+	return ret;
+}
+
+static void ce4100_mem_serial_out(struct uart_port *p, int offset, int value)
+{
+	offset = offset << p->regshift;
+	writel(value, p->membase + offset);
+}
+
+static void ce4100_serial_fixup(int port, struct uart_port *up,
+	u32 *capabilities)
+{
+#ifdef CONFIG_EARLY_PRINTK
+	/*
+	 * Over ride the legacy port configuration that comes from
+	 * asm/serial.h. Using the ioport driver then switching to the
+	 * PCI memmaped driver hangs the IOAPIC
+	 */
+	if (up->iotype !=  UPIO_MEM32) {
+		up->uartclk  = 14745600;
+		up->mapbase = 0xdffe0200;
+		set_fixmap_nocache(FIX_EARLYCON_MEM_BASE,
+				up->mapbase & PAGE_MASK);
+		up->membase =
+			(void __iomem *)__fix_to_virt(FIX_EARLYCON_MEM_BASE);
+		up->membase += up->mapbase & ~PAGE_MASK;
+		up->mapbase += port * 0x100;
+		up->membase += port * 0x100;
+		up->iotype   = UPIO_MEM32;
+		up->regshift = 2;
+		up->irq = 4;
+	}
+#endif
+	up->iobase = 0;
+	up->serial_in = ce4100_mem_serial_in;
+	up->serial_out = ce4100_mem_serial_out;
+
+	*capabilities |= (1 << 12);
+}
+
+static __init void sdv_serial_fixup(void)
+{
+	serial8250_set_isa_configurator(ce4100_serial_fixup);
+}
+
+#else
+static inline void sdv_serial_fixup(void) {};
+#endif
+
 static void __init sdv_arch_setup(void)
 {
 	sdv_serial_fixup();
diff --git a/drivers/isdn/capi/capi.c b/drivers/isdn/capi/capi.c
index 78e6e7748fb93..70dee9ad4bae2 100644
--- a/drivers/isdn/capi/capi.c
+++ b/drivers/isdn/capi/capi.c
@@ -306,9 +306,15 @@ static void capincci_alloc_minor(struct capidev *cdev, struct capincci *np)
 static void capincci_free_minor(struct capincci *np)
 {
 	struct capiminor *mp = np->minorp;
+	struct tty_struct *tty;
 
 	if (mp) {
-		tty_port_tty_vhangup(&mp->port);
+		tty = tty_port_tty_get(&mp->port);
+		if (tty) {
+			tty_vhangup(tty);
+			tty_kref_put(tty);
+		}
+
 		capiminor_free(mp);
 	}
 }
diff --git a/drivers/soc/qcom/qcom-geni-se.c b/drivers/soc/qcom/qcom-geni-se.c
index 3c3b796333a61..4cb959106efa9 100644
--- a/drivers/soc/qcom/qcom-geni-se.c
+++ b/drivers/soc/qcom/qcom-geni-se.c
@@ -895,7 +895,6 @@ static int geni_se_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct geni_wrapper *wrapper;
-	const struct geni_se_desc *desc;
 	int ret;
 
 	wrapper = devm_kzalloc(dev, sizeof(*wrapper), GFP_KERNEL);
@@ -907,11 +906,14 @@ static int geni_se_probe(struct platform_device *pdev)
 	if (IS_ERR(wrapper->base))
 		return PTR_ERR(wrapper->base);
 
-	desc = device_get_match_data(&pdev->dev);
-
-	if (!has_acpi_companion(&pdev->dev) && desc->num_clks) {
+	if (!has_acpi_companion(&pdev->dev)) {
+		const struct geni_se_desc *desc;
 		int i;
 
+		desc = device_get_match_data(&pdev->dev);
+		if (!desc)
+			return -EINVAL;
+
 		wrapper->num_clks = min_t(unsigned int, desc->num_clks, MAX_CLKS);
 
 		for (i = 0; i < wrapper->num_clks; ++i)
@@ -951,8 +953,6 @@ static const struct geni_se_desc qup_desc = {
 	.num_clks = ARRAY_SIZE(qup_clks),
 };
 
-static const struct geni_se_desc sa8255p_qup_desc = {};
-
 static const char * const i2c_master_hub_clks[] = {
 	"s-ahb",
 };
@@ -965,7 +965,6 @@ static const struct geni_se_desc i2c_master_hub_desc = {
 static const struct of_device_id geni_se_dt_match[] = {
 	{ .compatible = "qcom,geni-se-qup", .data = &qup_desc },
 	{ .compatible = "qcom,geni-se-i2c-master-hub", .data = &i2c_master_hub_desc },
-	{ .compatible = "qcom,sa8255p-geni-se-qup", .data = &sa8255p_qup_desc },
 	{}
 };
 MODULE_DEVICE_TABLE(of, geni_se_dt_match);
diff --git a/drivers/staging/greybus/uart.c b/drivers/staging/greybus/uart.c
index 10df5c37c83ed..308ed1ca99472 100644
--- a/drivers/staging/greybus/uart.c
+++ b/drivers/staging/greybus/uart.c
@@ -916,6 +916,7 @@ static void gb_uart_remove(struct gbphy_device *gbphy_dev)
 {
 	struct gb_tty *gb_tty = gb_gbphy_get_data(gbphy_dev);
 	struct gb_connection *connection = gb_tty->connection;
+	struct tty_struct *tty;
 	int ret;
 
 	ret = gbphy_runtime_get_sync(gbphy_dev);
@@ -928,7 +929,11 @@ static void gb_uart_remove(struct gbphy_device *gbphy_dev)
 	wake_up_all(&gb_tty->wioctl);
 	mutex_unlock(&gb_tty->mutex);
 
-	tty_port_tty_vhangup(&gb_tty->port);
+	tty = tty_port_tty_get(&gb_tty->port);
+	if (tty) {
+		tty_vhangup(tty);
+		tty_kref_put(tty);
+	}
 
 	gb_connection_disable_rx(connection);
 	tty_unregister_device(gb_tty_driver, gb_tty->minor);
diff --git a/drivers/tty/serial/8250/8250.h b/drivers/tty/serial/8250/8250.h
index cfe6ba286b45f..18530c31a5981 100644
--- a/drivers/tty/serial/8250/8250.h
+++ b/drivers/tty/serial/8250/8250.h
@@ -318,16 +318,8 @@ static inline void serial8250_pnp_exit(void) { }
 
 #ifdef CONFIG_SERIAL_8250_RSA
 void univ8250_rsa_support(struct uart_ops *ops);
-void rsa_enable(struct uart_8250_port *up);
-void rsa_disable(struct uart_8250_port *up);
-void rsa_autoconfig(struct uart_8250_port *up);
-void rsa_reset(struct uart_8250_port *up);
 #else
 static inline void univ8250_rsa_support(struct uart_ops *ops) { }
-static inline void rsa_enable(struct uart_8250_port *up) {}
-static inline void rsa_disable(struct uart_8250_port *up) {}
-static inline void rsa_autoconfig(struct uart_8250_port *up) {}
-static inline void rsa_reset(struct uart_8250_port *up) {}
 #endif
 
 #ifdef CONFIG_SERIAL_8250_FINTEK
diff --git a/drivers/tty/serial/8250/8250_ce4100.c b/drivers/tty/serial/8250/8250_ce4100.c
deleted file mode 100644
index 81dfb2adbabdd..0000000000000
--- a/drivers/tty/serial/8250/8250_ce4100.c
+++ /dev/null
@@ -1,93 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-only
-/*
- * Intel CE4100  platform specific setup code
- *
- * (C) Copyright 2010 Intel Corporation
- */
-
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/types.h>
-
-#include <asm/ce4100.h>
-#include <asm/fixmap.h>
-#include <asm/page.h>
-
-#include <linux/serial_reg.h>
-#include <linux/serial_8250.h>
-
-static unsigned int mem_serial_in(struct uart_port *p, int offset)
-{
-	offset = offset << p->regshift;
-	return readl(p->membase + offset);
-}
-
-/*
- * The UART Tx interrupts are not set under some conditions and therefore serial
- * transmission hangs. This is a silicon issue and has not been root caused. The
- * workaround for this silicon issue checks UART_LSR_THRE bit and UART_LSR_TEMT
- * bit of LSR register in interrupt handler to see whether at least one of these
- * two bits is set, if so then process the transmit request. If this workaround
- * is not applied, then the serial transmission may hang. This workaround is for
- * errata number 9 in Errata - B step.
-*/
-static u32 ce4100_mem_serial_in(struct uart_port *p, unsigned int offset)
-{
-	u32 ret, ier, lsr;
-
-	ret = mem_serial_in(p, offset);
-	if (offset != UART_IIR || !(ret & UART_IIR_NO_INT))
-		return ret;
-
-	/* see if the TX interrupt should have really set */
-	ier = mem_serial_in(p, UART_IER);
-	/* see if the UART's XMIT interrupt is enabled */
-	if (!(ier & UART_IER_THRI))
-		return ret;
-
-	lsr = mem_serial_in(p, UART_LSR);
-	/* now check to see if the UART should be generating an interrupt (but isn't) */
-	if (lsr & (UART_LSR_THRE | UART_LSR_TEMT))
-		ret &= ~UART_IIR_NO_INT;
-
-	return ret;
-}
-
-static void ce4100_mem_serial_out(struct uart_port *p, unsigned int offset, u32 value)
-{
-	offset <<= p->regshift;
-	writel(value, p->membase + offset);
-}
-
-static void ce4100_serial_fixup(int port, struct uart_port *up, u32 *capabilities)
-{
-#ifdef CONFIG_EARLY_PRINTK
-	/*
-	 * Override the legacy port configuration that comes from
-	 * asm/serial.h. Using the ioport driver then switching to the
-	 * PCI memmaped driver hangs the IOAPIC.
-	 */
-	if (up->iotype != UPIO_MEM32) {
-		up->uartclk = 14745600;
-		up->mapbase = 0xdffe0200;
-		set_fixmap_nocache(FIX_EARLYCON_MEM_BASE, up->mapbase & PAGE_MASK);
-		up->membase = (void __iomem *)__fix_to_virt(FIX_EARLYCON_MEM_BASE);
-		up->membase += up->mapbase & ~PAGE_MASK;
-		up->mapbase += port * 0x100;
-		up->membase += port * 0x100;
-		up->iotype = UPIO_MEM32;
-		up->regshift = 2;
-		up->irq = 4;
-	}
-#endif
-	up->iobase = 0;
-	up->serial_in = ce4100_mem_serial_in;
-	up->serial_out = ce4100_mem_serial_out;
-
-	*capabilities |= (1 << 12);
-}
-
-void __init sdv_serial_fixup(void)
-{
-	serial8250_set_isa_configurator(ce4100_serial_fixup);
-}
diff --git a/drivers/tty/serial/8250/8250_core.c b/drivers/tty/serial/8250/8250_core.c
index feb920c5b2e80..7a6050f1c094b 100644
--- a/drivers/tty/serial/8250/8250_core.c
+++ b/drivers/tty/serial/8250/8250_core.c
@@ -13,7 +13,6 @@
  */
 
 #include <linux/acpi.h>
-#include <linux/hashtable.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/ioport.h>
@@ -48,8 +47,8 @@ struct irq_info {
 	struct list_head	*head;
 };
 
-#define IRQ_HASH_BITS		5	/* Can be adjusted later */
-static DEFINE_HASHTABLE(irq_lists, IRQ_HASH_BITS);
+#define NR_IRQ_HASH		32	/* Can be adjusted later */
+static struct hlist_head irq_lists[NR_IRQ_HASH];
 static DEFINE_MUTEX(hash_mutex);	/* Used to walk the hash */
 
 /*
@@ -72,12 +71,17 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 	struct list_head *l, *end = NULL;
 	int pass_counter = 0, handled = 0;
 
+	pr_debug("%s(%d): start\n", __func__, irq);
+
 	spin_lock(&i->lock);
 
 	l = i->head;
 	do {
-		struct uart_8250_port *up = list_entry(l, struct uart_8250_port, list);
-		struct uart_port *port = &up->port;
+		struct uart_8250_port *up;
+		struct uart_port *port;
+
+		up = list_entry(l, struct uart_8250_port, list);
+		port = &up->port;
 
 		if (port->handle_irq(port)) {
 			handled = 1;
@@ -93,6 +97,8 @@ static irqreturn_t serial8250_interrupt(int irq, void *dev_id)
 
 	spin_unlock(&i->lock);
 
+	pr_debug("%s(%d): end\n", __func__, irq);
+
 	return IRQ_RETVAL(handled);
 }
 
@@ -123,44 +129,32 @@ static void serial_do_unlink(struct irq_info *i, struct uart_8250_port *up)
 	}
 }
 
-/*
- * Either:
- * - find the corresponding info in the hashtable and return it, or
- * - allocate a new one, add it to the hashtable and return it.
- */
-static struct irq_info *serial_get_or_create_irq_info(const struct uart_8250_port *up)
+static int serial_link_irq_chain(struct uart_8250_port *up)
 {
+	struct hlist_head *h;
 	struct irq_info *i;
+	int ret;
 
 	mutex_lock(&hash_mutex);
 
-	hash_for_each_possible(irq_lists, i, node, up->port.irq)
+	h = &irq_lists[up->port.irq % NR_IRQ_HASH];
+
+	hlist_for_each_entry(i, h, node)
 		if (i->irq == up->port.irq)
-			goto unlock;
+			break;
 
-	i = kzalloc(sizeof(*i), GFP_KERNEL);
 	if (i == NULL) {
-		i = ERR_PTR(-ENOMEM);
-		goto unlock;
+		i = kzalloc(sizeof(struct irq_info), GFP_KERNEL);
+		if (i == NULL) {
+			mutex_unlock(&hash_mutex);
+			return -ENOMEM;
+		}
+		spin_lock_init(&i->lock);
+		i->irq = up->port.irq;
+		hlist_add_head(&i->node, h);
 	}
-	spin_lock_init(&i->lock);
-	i->irq = up->port.irq;
-	hash_add(irq_lists, &i->node, i->irq);
-unlock:
 	mutex_unlock(&hash_mutex);
 
-	return i;
-}
-
-static int serial_link_irq_chain(struct uart_8250_port *up)
-{
-	struct irq_info *i;
-	int ret;
-
-	i = serial_get_or_create_irq_info(up);
-	if (IS_ERR(i))
-		return PTR_ERR(i);
-
 	spin_lock_irq(&i->lock);
 
 	if (i->head) {
@@ -184,10 +178,13 @@ static int serial_link_irq_chain(struct uart_8250_port *up)
 static void serial_unlink_irq_chain(struct uart_8250_port *up)
 {
 	struct irq_info *i;
+	struct hlist_head *h;
 
 	mutex_lock(&hash_mutex);
 
-	hash_for_each_possible(irq_lists, i, node, up->port.irq)
+	h = &irq_lists[up->port.irq % NR_IRQ_HASH];
+
+	hlist_for_each_entry(i, h, node)
 		if (i->irq == up->port.irq)
 			break;
 
@@ -717,142 +714,139 @@ int serial8250_register_8250_port(const struct uart_8250_port *up)
 		nr_uarts++;
 	}
 
-	/* Check if it is CIR already. We check this below again, see there why. */
-	if (uart->port.type == PORT_8250_CIR) {
-		ret = -ENODEV;
-		goto unlock;
-	}
-
-	if (uart->port.dev)
-		uart_remove_one_port(&serial8250_reg, &uart->port);
-
-	uart->port.ctrl_id	= up->port.ctrl_id;
-	uart->port.port_id	= up->port.port_id;
-	uart->port.iobase       = up->port.iobase;
-	uart->port.membase      = up->port.membase;
-	uart->port.irq          = up->port.irq;
-	uart->port.irqflags     = up->port.irqflags;
-	uart->port.uartclk      = up->port.uartclk;
-	uart->port.fifosize     = up->port.fifosize;
-	uart->port.regshift     = up->port.regshift;
-	uart->port.iotype       = up->port.iotype;
-	uart->port.flags        = up->port.flags | UPF_BOOT_AUTOCONF;
-	uart->bugs		= up->bugs;
-	uart->port.mapbase      = up->port.mapbase;
-	uart->port.mapsize      = up->port.mapsize;
-	uart->port.private_data = up->port.private_data;
-	uart->tx_loadsz		= up->tx_loadsz;
-	uart->capabilities	= up->capabilities;
-	uart->port.throttle	= up->port.throttle;
-	uart->port.unthrottle	= up->port.unthrottle;
-	uart->port.rs485_config	= up->port.rs485_config;
-	uart->port.rs485_supported = up->port.rs485_supported;
-	uart->port.rs485	= up->port.rs485;
-	uart->rs485_start_tx	= up->rs485_start_tx;
-	uart->rs485_stop_tx	= up->rs485_stop_tx;
-	uart->lsr_save_mask	= up->lsr_save_mask;
-	uart->dma		= up->dma;
-
-	/* Take tx_loadsz from fifosize if it wasn't set separately */
-	if (uart->port.fifosize && !uart->tx_loadsz)
-		uart->tx_loadsz = uart->port.fifosize;
-
-	if (up->port.dev) {
-		uart->port.dev = up->port.dev;
-		ret = uart_get_rs485_mode(&uart->port);
-		if (ret)
-			goto err;
-	}
-
-	if (up->port.flags & UPF_FIXED_TYPE)
-		uart->port.type = up->port.type;
-
-	/*
-	 * Only call mctrl_gpio_init(), if the device has no ACPI
-	 * companion device
-	 */
-	if (!has_acpi_companion(uart->port.dev)) {
-		struct mctrl_gpios *gpios = mctrl_gpio_init(&uart->port, 0);
-		if (IS_ERR(gpios)) {
-			ret = PTR_ERR(gpios);
-			goto err;
-		} else {
-			uart->gpios = gpios;
-		}
-	}
-
-	serial8250_set_defaults(uart);
-
-	/* Possibly override default I/O functions.  */
-	if (up->port.serial_in)
-		uart->port.serial_in = up->port.serial_in;
-	if (up->port.serial_out)
-		uart->port.serial_out = up->port.serial_out;
-	if (up->port.handle_irq)
-		uart->port.handle_irq = up->port.handle_irq;
-	/*  Possibly override set_termios call */
-	if (up->port.set_termios)
-		uart->port.set_termios = up->port.set_termios;
-	if (up->port.set_ldisc)
-		uart->port.set_ldisc = up->port.set_ldisc;
-	if (up->port.get_mctrl)
-		uart->port.get_mctrl = up->port.get_mctrl;
-	if (up->port.set_mctrl)
-		uart->port.set_mctrl = up->port.set_mctrl;
-	if (up->port.get_divisor)
-		uart->port.get_divisor = up->port.get_divisor;
-	if (up->port.set_divisor)
-		uart->port.set_divisor = up->port.set_divisor;
-	if (up->port.startup)
-		uart->port.startup = up->port.startup;
-	if (up->port.shutdown)
-		uart->port.shutdown = up->port.shutdown;
-	if (up->port.pm)
-		uart->port.pm = up->port.pm;
-	if (up->port.handle_break)
-		uart->port.handle_break = up->port.handle_break;
-	if (up->dl_read)
-		uart->dl_read = up->dl_read;
-	if (up->dl_write)
-		uart->dl_write = up->dl_write;
-
-	/* Check the type (again)! It might have changed by the port.type assignment above. */
 	if (uart->port.type != PORT_8250_CIR) {
-		if (uart_console_registered(&uart->port))
-			pm_runtime_get_sync(uart->port.dev);
+		struct mctrl_gpios *gpios;
+
+		if (uart->port.dev)
+			uart_remove_one_port(&serial8250_reg, &uart->port);
+
+		uart->port.ctrl_id	= up->port.ctrl_id;
+		uart->port.port_id	= up->port.port_id;
+		uart->port.iobase       = up->port.iobase;
+		uart->port.membase      = up->port.membase;
+		uart->port.irq          = up->port.irq;
+		uart->port.irqflags     = up->port.irqflags;
+		uart->port.uartclk      = up->port.uartclk;
+		uart->port.fifosize     = up->port.fifosize;
+		uart->port.regshift     = up->port.regshift;
+		uart->port.iotype       = up->port.iotype;
+		uart->port.flags        = up->port.flags | UPF_BOOT_AUTOCONF;
+		uart->bugs		= up->bugs;
+		uart->port.mapbase      = up->port.mapbase;
+		uart->port.mapsize      = up->port.mapsize;
+		uart->port.private_data = up->port.private_data;
+		uart->tx_loadsz		= up->tx_loadsz;
+		uart->capabilities	= up->capabilities;
+		uart->port.throttle	= up->port.throttle;
+		uart->port.unthrottle	= up->port.unthrottle;
+		uart->port.rs485_config	= up->port.rs485_config;
+		uart->port.rs485_supported = up->port.rs485_supported;
+		uart->port.rs485	= up->port.rs485;
+		uart->rs485_start_tx	= up->rs485_start_tx;
+		uart->rs485_stop_tx	= up->rs485_stop_tx;
+		uart->lsr_save_mask	= up->lsr_save_mask;
+		uart->dma		= up->dma;
+
+		/* Take tx_loadsz from fifosize if it wasn't set separately */
+		if (uart->port.fifosize && !uart->tx_loadsz)
+			uart->tx_loadsz = uart->port.fifosize;
+
+		if (up->port.dev) {
+			uart->port.dev = up->port.dev;
+			ret = uart_get_rs485_mode(&uart->port);
+			if (ret)
+				goto err;
+		}
 
-		if (serial8250_isa_config != NULL)
-			serial8250_isa_config(0, &uart->port,
-					&uart->capabilities);
+		if (up->port.flags & UPF_FIXED_TYPE)
+			uart->port.type = up->port.type;
 
-		serial8250_apply_quirks(uart);
-		ret = uart_add_one_port(&serial8250_reg,
-					&uart->port);
-		if (ret)
-			goto err;
+		/*
+		 * Only call mctrl_gpio_init(), if the device has no ACPI
+		 * companion device
+		 */
+		if (!has_acpi_companion(uart->port.dev)) {
+			gpios = mctrl_gpio_init(&uart->port, 0);
+			if (IS_ERR(gpios)) {
+				ret = PTR_ERR(gpios);
+				goto err;
+			} else {
+				uart->gpios = gpios;
+			}
+		}
 
-		ret = uart->port.line;
-	} else {
-		dev_info(uart->port.dev,
-			"skipping CIR port at 0x%lx / 0x%llx, IRQ %d\n",
-			uart->port.iobase,
-			(unsigned long long)uart->port.mapbase,
-			uart->port.irq);
+		serial8250_set_defaults(uart);
+
+		/* Possibly override default I/O functions.  */
+		if (up->port.serial_in)
+			uart->port.serial_in = up->port.serial_in;
+		if (up->port.serial_out)
+			uart->port.serial_out = up->port.serial_out;
+		if (up->port.handle_irq)
+			uart->port.handle_irq = up->port.handle_irq;
+		/*  Possibly override set_termios call */
+		if (up->port.set_termios)
+			uart->port.set_termios = up->port.set_termios;
+		if (up->port.set_ldisc)
+			uart->port.set_ldisc = up->port.set_ldisc;
+		if (up->port.get_mctrl)
+			uart->port.get_mctrl = up->port.get_mctrl;
+		if (up->port.set_mctrl)
+			uart->port.set_mctrl = up->port.set_mctrl;
+		if (up->port.get_divisor)
+			uart->port.get_divisor = up->port.get_divisor;
+		if (up->port.set_divisor)
+			uart->port.set_divisor = up->port.set_divisor;
+		if (up->port.startup)
+			uart->port.startup = up->port.startup;
+		if (up->port.shutdown)
+			uart->port.shutdown = up->port.shutdown;
+		if (up->port.pm)
+			uart->port.pm = up->port.pm;
+		if (up->port.handle_break)
+			uart->port.handle_break = up->port.handle_break;
+		if (up->dl_read)
+			uart->dl_read = up->dl_read;
+		if (up->dl_write)
+			uart->dl_write = up->dl_write;
+
+		if (uart->port.type != PORT_8250_CIR) {
+			if (uart_console_registered(&uart->port))
+				pm_runtime_get_sync(uart->port.dev);
+
+			if (serial8250_isa_config != NULL)
+				serial8250_isa_config(0, &uart->port,
+						&uart->capabilities);
+
+			serial8250_apply_quirks(uart);
+			ret = uart_add_one_port(&serial8250_reg,
+						&uart->port);
+			if (ret)
+				goto err;
+
+			ret = uart->port.line;
+		} else {
+			dev_info(uart->port.dev,
+				"skipping CIR port at 0x%lx / 0x%llx, IRQ %d\n",
+				uart->port.iobase,
+				(unsigned long long)uart->port.mapbase,
+				uart->port.irq);
 
-		ret = 0;
-	}
+			ret = 0;
+		}
 
-	if (!uart->lsr_save_mask)
-		uart->lsr_save_mask = LSR_SAVE_FLAGS;	/* Use default LSR mask */
+		if (!uart->lsr_save_mask)
+			uart->lsr_save_mask = LSR_SAVE_FLAGS;	/* Use default LSR mask */
 
-	/* Initialise interrupt backoff work if required */
-	if (up->overrun_backoff_time_ms > 0) {
-		uart->overrun_backoff_time_ms =
-			up->overrun_backoff_time_ms;
-		INIT_DELAYED_WORK(&uart->overrun_backoff,
-				serial_8250_overrun_backoff_work);
-	} else {
-		uart->overrun_backoff_time_ms = 0;
+		/* Initialise interrupt backoff work if required */
+		if (up->overrun_backoff_time_ms > 0) {
+			uart->overrun_backoff_time_ms =
+				up->overrun_backoff_time_ms;
+			INIT_DELAYED_WORK(&uart->overrun_backoff,
+					serial_8250_overrun_backoff_work);
+		} else {
+			uart->overrun_backoff_time_ms = 0;
+		}
 	}
 
 unlock:
diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index a53ba04d97701..1902f29444a1c 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -67,8 +67,8 @@ struct dw8250_data {
 	struct dw8250_port_data	data;
 	const struct dw8250_platform_data *pdata;
 
-	u32			msr_mask_on;
-	u32			msr_mask_off;
+	int			msr_mask_on;
+	int			msr_mask_off;
 	struct clk		*clk;
 	struct clk		*pclk;
 	struct notifier_block	clk_notifier;
@@ -94,7 +94,7 @@ static inline struct dw8250_data *work_to_dw8250_data(struct work_struct *work)
 	return container_of(work, struct dw8250_data, clk_work);
 }
 
-static inline u32 dw8250_modify_msr(struct uart_port *p, unsigned int offset, u32 value)
+static inline int dw8250_modify_msr(struct uart_port *p, int offset, int value)
 {
 	struct dw8250_data *d = to_dw8250_data(p->private_data);
 
@@ -145,7 +145,7 @@ static void dw8250_force_idle(struct uart_port *p)
  * routine. Hence, it must not call serial_port_out() or serial_out()
  * against the modified registers here, i.e. LCR.
  */
-static void dw8250_check_lcr(struct uart_port *p, unsigned int offset, u32 value)
+static void dw8250_check_lcr(struct uart_port *p, int offset, int value)
 {
 	struct dw8250_data *d = to_dw8250_data(p->private_data);
 	void __iomem *addr = p->membase + (offset << p->regshift);
@@ -156,7 +156,7 @@ static void dw8250_check_lcr(struct uart_port *p, unsigned int offset, u32 value
 
 	/* Make sure LCR write wasn't ignored */
 	while (tries--) {
-		u32 lcr = serial_port_in(p, offset);
+		unsigned int lcr = serial_port_in(p, offset);
 
 		if ((value & ~UART_LCR_SPAR) == (lcr & ~UART_LCR_SPAR))
 			return;
@@ -205,13 +205,13 @@ static void dw8250_tx_wait_empty(struct uart_port *p)
 	}
 }
 
-static void dw8250_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void dw8250_serial_out(struct uart_port *p, int offset, int value)
 {
 	writeb(value, p->membase + (offset << p->regshift));
 	dw8250_check_lcr(p, offset, value);
 }
 
-static void dw8250_serial_out38x(struct uart_port *p, unsigned int offset, u32 value)
+static void dw8250_serial_out38x(struct uart_port *p, int offset, int value)
 {
 	/* Allow the TX to drain before we reconfigure */
 	if (offset == UART_LCR)
@@ -220,22 +220,22 @@ static void dw8250_serial_out38x(struct uart_port *p, unsigned int offset, u32 v
 	dw8250_serial_out(p, offset, value);
 }
 
-static u32 dw8250_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int dw8250_serial_in(struct uart_port *p, int offset)
 {
-	u32 value = readb(p->membase + (offset << p->regshift));
+	unsigned int value = readb(p->membase + (offset << p->regshift));
 
 	return dw8250_modify_msr(p, offset, value);
 }
 
 #ifdef CONFIG_64BIT
-static u32 dw8250_serial_inq(struct uart_port *p, unsigned int offset)
+static unsigned int dw8250_serial_inq(struct uart_port *p, int offset)
 {
 	u8 value = __raw_readq(p->membase + (offset << p->regshift));
 
 	return dw8250_modify_msr(p, offset, value);
 }
 
-static void dw8250_serial_outq(struct uart_port *p, unsigned int offset, u32 value)
+static void dw8250_serial_outq(struct uart_port *p, int offset, int value)
 {
 	value &= 0xff;
 	__raw_writeq(value, p->membase + (offset << p->regshift));
@@ -246,28 +246,28 @@ static void dw8250_serial_outq(struct uart_port *p, unsigned int offset, u32 val
 }
 #endif /* CONFIG_64BIT */
 
-static void dw8250_serial_out32(struct uart_port *p, unsigned int offset, u32 value)
+static void dw8250_serial_out32(struct uart_port *p, int offset, int value)
 {
 	writel(value, p->membase + (offset << p->regshift));
 	dw8250_check_lcr(p, offset, value);
 }
 
-static u32 dw8250_serial_in32(struct uart_port *p, unsigned int offset)
+static unsigned int dw8250_serial_in32(struct uart_port *p, int offset)
 {
-	u32 value = readl(p->membase + (offset << p->regshift));
+	unsigned int value = readl(p->membase + (offset << p->regshift));
 
 	return dw8250_modify_msr(p, offset, value);
 }
 
-static void dw8250_serial_out32be(struct uart_port *p, unsigned int offset, u32 value)
+static void dw8250_serial_out32be(struct uart_port *p, int offset, int value)
 {
 	iowrite32be(value, p->membase + (offset << p->regshift));
 	dw8250_check_lcr(p, offset, value);
 }
 
-static u32 dw8250_serial_in32be(struct uart_port *p, unsigned int offset)
+static unsigned int dw8250_serial_in32be(struct uart_port *p, int offset)
 {
-       u32 value = ioread32be(p->membase + (offset << p->regshift));
+       unsigned int value = ioread32be(p->membase + (offset << p->regshift));
 
        return dw8250_modify_msr(p, offset, value);
 }
@@ -392,7 +392,7 @@ static void dw8250_set_termios(struct uart_port *p, struct ktermios *termios,
 	rate = clk_round_rate(d->clk, newrate);
 	if (rate > 0) {
 		/*
-		 * Note that any clock-notifier worker will block in
+		 * Note that any clock-notifer worker will block in
 		 * serial8250_update_uartclk() until we are done.
 		 */
 		ret = clk_set_rate(d->clk, newrate);
diff --git a/drivers/tty/serial/8250/8250_em.c b/drivers/tty/serial/8250/8250_em.c
index e90c714949449..35094f884492c 100644
--- a/drivers/tty/serial/8250/8250_em.c
+++ b/drivers/tty/serial/8250/8250_em.c
@@ -59,7 +59,7 @@ static void serial8250_em_serial_out_helper(struct uart_port *p, int offset,
 	}
 }
 
-static u32 serial8250_em_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int serial8250_em_serial_in(struct uart_port *p, int offset)
 {
 	switch (offset) {
 	case UART_RX: /* RX @ 0x00 */
@@ -119,7 +119,7 @@ static void serial8250_em_reg_update(struct uart_port *p, int off, int value)
 	serial8250_em_serial_out_helper(p, UART_HCR0_EM, hcr0);
 }
 
-static void serial8250_em_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void serial8250_em_serial_out(struct uart_port *p, int offset, int value)
 {
 	switch (offset) {
 	case UART_TX:
diff --git a/drivers/tty/serial/8250/8250_ingenic.c b/drivers/tty/serial/8250/8250_ingenic.c
index 94542fc143c2d..a73dd37736404 100644
--- a/drivers/tty/serial/8250/8250_ingenic.c
+++ b/drivers/tty/serial/8250/8250_ingenic.c
@@ -168,9 +168,9 @@ OF_EARLYCON_DECLARE(jz4780_uart, "ingenic,jz4780-uart",
 OF_EARLYCON_DECLARE(x1000_uart, "ingenic,x1000-uart",
 		    ingenic_early_console_setup);
 
-static void ingenic_uart_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void ingenic_uart_serial_out(struct uart_port *p, int offset, int value)
 {
-	u32 ier;
+	int ier;
 
 	switch (offset) {
 	case UART_FCR:
@@ -206,9 +206,9 @@ static void ingenic_uart_serial_out(struct uart_port *p, unsigned int offset, u3
 	writeb(value, p->membase + (offset << p->regshift));
 }
 
-static u32 ingenic_uart_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int ingenic_uart_serial_in(struct uart_port *p, int offset)
 {
-	u8 value;
+	unsigned int value;
 
 	value = readb(p->membase + (offset << p->regshift));
 
diff --git a/drivers/tty/serial/8250/8250_ioc3.c b/drivers/tty/serial/8250/8250_ioc3.c
index 3ebda9a5d07db..499e80aa4cf96 100644
--- a/drivers/tty/serial/8250/8250_ioc3.c
+++ b/drivers/tty/serial/8250/8250_ioc3.c
@@ -21,12 +21,12 @@ struct ioc3_8250_data {
 	int line;
 };
 
-static u32 ioc3_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int ioc3_serial_in(struct uart_port *p, int offset)
 {
 	return readb(p->membase + (offset ^ 3));
 }
 
-static void ioc3_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void ioc3_serial_out(struct uart_port *p, int offset, int value)
 {
 	writeb(value, p->membase + (offset ^ 3));
 }
diff --git a/drivers/tty/serial/8250/8250_lpc18xx.c b/drivers/tty/serial/8250/8250_lpc18xx.c
index 6c0489c9c2535..d52445948da0b 100644
--- a/drivers/tty/serial/8250/8250_lpc18xx.c
+++ b/drivers/tty/serial/8250/8250_lpc18xx.c
@@ -67,7 +67,7 @@ static int lpc18xx_rs485_config(struct uart_port *port, struct ktermios *termios
 	return 0;
 }
 
-static void lpc18xx_uart_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void lpc18xx_uart_serial_out(struct uart_port *p, int offset, int value)
 {
 	/*
 	 * For DMA mode one must ensure that the UART_FCR_DMA_SELECT
diff --git a/drivers/tty/serial/8250/8250_ni.c b/drivers/tty/serial/8250/8250_ni.c
index cb5b42b3609c9..b0e44fb00b3a4 100644
--- a/drivers/tty/serial/8250/8250_ni.c
+++ b/drivers/tty/serial/8250/8250_ni.c
@@ -275,80 +275,76 @@ static void ni16550_set_mctrl(struct uart_port *port, unsigned int mctrl)
 
 static int ni16550_probe(struct platform_device *pdev)
 {
-	struct uart_8250_port *uart __free(kfree) = NULL;
 	const struct ni16550_device_info *info;
 	struct device *dev = &pdev->dev;
+	struct uart_8250_port uart = {};
 	unsigned int txfifosz, rxfifosz;
-	struct ni16550_data *data;
 	unsigned int prescaler;
+	struct ni16550_data *data;
 	const char *portmode;
 	bool rs232_property;
 	int ret;
 
-	uart = kzalloc(sizeof(*uart), GFP_KERNEL);
-	if (!uart)
-		return -ENOMEM;
-
 	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
 
-	spin_lock_init(&uart->port.lock);
+	spin_lock_init(&uart.port.lock);
 
-	ret = ni16550_get_regs(pdev, &uart->port);
+	ret = ni16550_get_regs(pdev, &uart.port);
 	if (ret < 0)
 		return ret;
 
 	/* early setup so that serial_in()/serial_out() work */
-	serial8250_set_defaults(uart);
+	serial8250_set_defaults(&uart);
 
 	info = device_get_match_data(dev);
 
-	uart->port.dev		= dev;
-	uart->port.flags	= UPF_BOOT_AUTOCONF | UPF_FIXED_PORT | UPF_FIXED_TYPE;
-	uart->port.startup	= ni16550_port_startup;
-	uart->port.shutdown	= ni16550_port_shutdown;
+	uart.port.dev		= dev;
+	uart.port.flags		= UPF_BOOT_AUTOCONF | UPF_FIXED_PORT | UPF_FIXED_TYPE;
+	uart.port.startup	= ni16550_port_startup;
+	uart.port.shutdown	= ni16550_port_shutdown;
 
 	/*
 	 * Hardware instantiation of FIFO sizes are held in registers.
 	 */
-	txfifosz = ni16550_read_fifo_size(uart, NI16550_TFS_OFFSET);
-	rxfifosz = ni16550_read_fifo_size(uart, NI16550_RFS_OFFSET);
+	txfifosz = ni16550_read_fifo_size(&uart, NI16550_TFS_OFFSET);
+	rxfifosz = ni16550_read_fifo_size(&uart, NI16550_RFS_OFFSET);
 
 	dev_dbg(dev, "NI 16550 has TX FIFO size %u, RX FIFO size %u\n",
 		txfifosz, rxfifosz);
 
-	uart->port.type		= PORT_16550A;
-	uart->port.fifosize	= txfifosz;
-	uart->tx_loadsz		= txfifosz;
-	uart->fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10;
-	uart->capabilities	= UART_CAP_FIFO | UART_CAP_AFE | UART_CAP_EFR;
+	uart.port.type		= PORT_16550A;
+	uart.port.fifosize	= txfifosz;
+	uart.tx_loadsz		= txfifosz;
+	uart.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10;
+	uart.capabilities	= UART_CAP_FIFO | UART_CAP_AFE | UART_CAP_EFR;
 
 	/*
 	 * Declaration of the base clock frequency can come from one of:
 	 * - static declaration in this driver (for older ACPI IDs)
 	 * - a "clock-frequency" ACPI
 	 */
-	uart->port.uartclk = info->uartclk;
+	uart.port.uartclk = info->uartclk;
 
-	ret = uart_read_port_properties(&uart->port);
+	ret = uart_read_port_properties(&uart.port);
 	if (ret)
 		return ret;
 
-	if (!uart->port.uartclk) {
+	if (!uart.port.uartclk) {
 		data->clk = devm_clk_get_enabled(dev, NULL);
 		if (!IS_ERR(data->clk))
-			uart->port.uartclk = clk_get_rate(data->clk);
+			uart.port.uartclk = clk_get_rate(data->clk);
 	}
 
-	if (!uart->port.uartclk)
+	if (!uart.port.uartclk)
 		return dev_err_probe(dev, -ENODEV, "unable to determine clock frequency!\n");
 
 	prescaler = info->prescaler;
 	device_property_read_u32(dev, "clock-prescaler", &prescaler);
 	if (prescaler) {
-		uart->port.set_mctrl = ni16550_set_mctrl;
-		ni16550_config_prescaler(uart, (u8)prescaler);
+		uart.port.set_mctrl = ni16550_set_mctrl;
+		ni16550_config_prescaler(&uart, (u8)prescaler);
 	}
 
 	/*
@@ -366,7 +362,7 @@ static int ni16550_probe(struct platform_device *pdev)
 		dev_dbg(dev, "port is in %s mode (via device property)\n",
 			rs232_property ? "RS-232" : "RS-485");
 	} else if (info->flags & NI_HAS_PMR) {
-		rs232_property = is_pmr_rs232_mode(uart);
+		rs232_property = is_pmr_rs232_mode(&uart);
 
 		dev_dbg(dev, "port is in %s mode (via PMR)\n",
 			rs232_property ? "RS-232" : "RS-485");
@@ -381,10 +377,10 @@ static int ni16550_probe(struct platform_device *pdev)
 		 * Neither the 'transceiver' property nor the PMR indicate
 		 * that this is an RS-232 port, so it must be an RS-485 one.
 		 */
-		ni16550_rs485_setup(&uart->port);
+		ni16550_rs485_setup(&uart.port);
 	}
 
-	ret = serial8250_register_8250_port(uart);
+	ret = serial8250_register_8250_port(&uart);
 	if (ret < 0)
 		return ret;
 	data->line = ret;
diff --git a/drivers/tty/serial/8250/8250_omap.c b/drivers/tty/serial/8250/8250_omap.c
index 6707f55bdbe71..72ae08d6204ff 100644
--- a/drivers/tty/serial/8250/8250_omap.c
+++ b/drivers/tty/serial/8250/8250_omap.c
@@ -176,7 +176,7 @@ static u32 uart_read(struct omap8250_priv *priv, u32 reg)
 static void __omap8250_set_mctrl(struct uart_port *port, unsigned int mctrl)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
-	struct omap8250_priv *priv = port->private_data;
+	struct omap8250_priv *priv = up->port.private_data;
 	u8 lcr;
 
 	serial8250_do_set_mctrl(port, mctrl);
@@ -303,13 +303,12 @@ static void omap8250_update_mdr1(struct uart_8250_port *up,
 
 static void omap8250_restore_regs(struct uart_8250_port *up)
 {
-	struct uart_port *port = &up->port;
-	struct omap8250_priv *priv = port->private_data;
+	struct omap8250_priv *priv = up->port.private_data;
 	struct uart_8250_dma	*dma = up->dma;
 	u8 mcr = serial8250_in_MCR(up);
 
 	/* Port locked to synchronize UART_IER access against the console. */
-	lockdep_assert_held_once(&port->lock);
+	lockdep_assert_held_once(&up->port.lock);
 
 	if (dma && dma->tx_running) {
 		/*
@@ -360,12 +359,12 @@ static void omap8250_restore_regs(struct uart_8250_port *up)
 
 	omap8250_update_mdr1(up, priv);
 
-	__omap8250_set_mctrl(port, port->mctrl);
+	__omap8250_set_mctrl(&up->port, up->port.mctrl);
 
 	serial_out(up, UART_OMAP_MDR3, priv->mdr3);
 
-	if (port->rs485.flags & SER_RS485_ENABLED &&
-	    port->rs485_config == serial8250_em485_config)
+	if (up->port.rs485.flags & SER_RS485_ENABLED &&
+	    up->port.rs485_config == serial8250_em485_config)
 		serial8250_em485_stop_tx(up, true);
 }
 
@@ -378,7 +377,7 @@ static void omap_8250_set_termios(struct uart_port *port,
 				  const struct ktermios *old)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
-	struct omap8250_priv *priv = port->private_data;
+	struct omap8250_priv *priv = up->port.private_data;
 	unsigned char cval = 0;
 	unsigned int baud;
 
@@ -419,39 +418,39 @@ static void omap_8250_set_termios(struct uart_port *port,
 	 * ignoring of characters only occurs if the bit is set
 	 * in @ignore_status_mask as well.
 	 */
-	port->read_status_mask = UART_LSR_OE | UART_LSR_DR;
+	up->port.read_status_mask = UART_LSR_OE | UART_LSR_DR;
 	if (termios->c_iflag & INPCK)
-		port->read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+		up->port.read_status_mask |= UART_LSR_FE | UART_LSR_PE;
 	if (termios->c_iflag & (IGNBRK | PARMRK))
-		port->read_status_mask |= UART_LSR_BI;
+		up->port.read_status_mask |= UART_LSR_BI;
 
 	/*
 	 * Characters to ignore
 	 */
-	port->ignore_status_mask = 0;
+	up->port.ignore_status_mask = 0;
 	if (termios->c_iflag & IGNPAR)
-		port->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+		up->port.ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
 	if (termios->c_iflag & IGNBRK) {
-		port->ignore_status_mask |= UART_LSR_BI;
+		up->port.ignore_status_mask |= UART_LSR_BI;
 		/*
 		 * If we're ignoring parity and break indicators,
 		 * ignore overruns too (for real raw support).
 		 */
 		if (termios->c_iflag & IGNPAR)
-			port->ignore_status_mask |= UART_LSR_OE;
+			up->port.ignore_status_mask |= UART_LSR_OE;
 	}
 
 	/*
 	 * ignore all characters if CREAD is not set
 	 */
 	if ((termios->c_cflag & CREAD) == 0)
-		port->ignore_status_mask |= UART_LSR_DR;
+		up->port.ignore_status_mask |= UART_LSR_DR;
 
 	/*
 	 * Modem status interrupts
 	 */
 	up->ier &= ~UART_IER_MSI;
-	if (UART_ENABLE_MS(port, termios->c_cflag))
+	if (UART_ENABLE_MS(&up->port, termios->c_cflag))
 		up->ier |= UART_IER_MSI;
 
 	up->lcr = cval;
@@ -489,15 +488,15 @@ static void omap_8250_set_termios(struct uart_port *port,
 	priv->xoff = termios->c_cc[VSTOP];
 
 	priv->efr = 0;
-	port->status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS | UPSTAT_AUTOXOFF);
+	up->port.status &= ~(UPSTAT_AUTOCTS | UPSTAT_AUTORTS | UPSTAT_AUTOXOFF);
 
-	if (termios->c_cflag & CRTSCTS && port->flags & UPF_HARD_FLOW &&
+	if (termios->c_cflag & CRTSCTS && up->port.flags & UPF_HARD_FLOW &&
 	    !mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_RTS) &&
 	    !mctrl_gpio_to_gpiod(up->gpios, UART_GPIO_CTS)) {
 		/* Enable AUTOCTS (autoRTS is enabled when RTS is raised) */
-		port->status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;
+		up->port.status |= UPSTAT_AUTOCTS | UPSTAT_AUTORTS;
 		priv->efr |= UART_EFR_CTS;
-	} else	if (port->flags & UPF_SOFT_FLOW) {
+	} else	if (up->port.flags & UPF_SOFT_FLOW) {
 		/*
 		 * OMAP rx s/w flow control is borked; the transmitter remains
 		 * stuck off even if rx flow control is subsequently disabled
@@ -509,7 +508,7 @@ static void omap_8250_set_termios(struct uart_port *port,
 		 * Transmit XON1, XOFF1
 		 */
 		if (termios->c_iflag & IXOFF) {
-			port->status |= UPSTAT_AUTOXOFF;
+			up->port.status |= UPSTAT_AUTOXOFF;
 			priv->efr |= OMAP_UART_SW_TX;
 		}
 	}
@@ -771,7 +770,7 @@ static int omap_8250_startup(struct uart_port *port)
 		uart_port_unlock_irq(port);
 	}
 
-	enable_irq(port->irq);
+	enable_irq(up->port.irq);
 
 	pm_runtime_mark_last_busy(port->dev);
 	pm_runtime_put_autosuspend(port->dev);
@@ -798,7 +797,7 @@ static void omap_8250_shutdown(struct uart_port *port)
 	up->ier = 0;
 	serial_out(up, UART_IER, 0);
 	uart_port_unlock_irq(port);
-	disable_irq_nosync(port->irq);
+	disable_irq_nosync(up->port.irq);
 	dev_pm_clear_wake_irq(port->dev);
 
 	serial8250_release_dma(up);
@@ -1311,7 +1310,7 @@ static void am654_8250_handle_rx_dma(struct uart_8250_port *up, u8 iir,
 static int omap_8250_dma_handle_irq(struct uart_port *port)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
-	struct omap8250_priv *priv = port->private_data;
+	struct omap8250_priv *priv = up->port.private_data;
 	u16 status;
 	u8 iir;
 
@@ -1333,8 +1332,8 @@ static int omap_8250_dma_handle_irq(struct uart_port *port)
 
 	serial8250_modem_status(up);
 	if (status & UART_LSR_THRE && up->dma->tx_err) {
-		if (uart_tx_stopped(port) ||
-		    kfifo_is_empty(&port->state->port.xmit_fifo)) {
+		if (uart_tx_stopped(&up->port) ||
+		    kfifo_is_empty(&up->port.state->port.xmit_fifo)) {
 			up->dma->tx_err = 0;
 			serial8250_tx_chars(up);
 		} else  {
diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c
index 152f914c599dc..73c200127b089 100644
--- a/drivers/tty/serial/8250/8250_pci.c
+++ b/drivers/tty/serial/8250/8250_pci.c
@@ -1751,7 +1751,7 @@ static int pci_fintek_init(struct pci_dev *dev)
 	return max_port;
 }
 
-static void f815xxa_mem_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void f815xxa_mem_serial_out(struct uart_port *p, int offset, int value)
 {
 	struct f815xxa_data *data = p->private_data;
 	unsigned long flags;
@@ -1846,10 +1846,10 @@ static void kt_handle_break(struct uart_port *p)
 	serial8250_clear_and_reinit_fifos(up);
 }
 
-static u32 kt_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int kt_serial_in(struct uart_port *p, int offset)
 {
 	struct uart_8250_port *up = up_to_u8250p(p);
-	u32 val;
+	unsigned int val;
 
 	/*
 	 * When the Intel ME (management engine) gets reset its serial
diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index 2da9db960d09f..6d7b8c4667c9c 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -38,6 +38,15 @@
 
 #include "8250.h"
 
+/*
+ * Debugging.
+ */
+#if 0
+#define DEBUG_AUTOCONF(fmt...)	printk(fmt)
+#else
+#define DEBUG_AUTOCONF(fmt...)	do { } while (0)
+#endif
+
 /*
  * Here we define the default xmit fifo size used for each type of UART.
  */
@@ -330,14 +339,14 @@ static void default_serial_dl_write(struct uart_8250_port *up, u32 value)
 }
 
 #ifdef CONFIG_HAS_IOPORT
-static u32 hub6_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int hub6_serial_in(struct uart_port *p, int offset)
 {
 	offset = offset << p->regshift;
 	outb(p->hub6 - 1 + offset, p->iobase);
 	return inb(p->iobase + 1);
 }
 
-static void hub6_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void hub6_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = offset << p->regshift;
 	outb(p->hub6 - 1 + offset, p->iobase);
@@ -345,73 +354,73 @@ static void hub6_serial_out(struct uart_port *p, unsigned int offset, u32 value)
 }
 #endif /* CONFIG_HAS_IOPORT */
 
-static u32 mem_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int mem_serial_in(struct uart_port *p, int offset)
 {
 	offset = offset << p->regshift;
 	return readb(p->membase + offset);
 }
 
-static void mem_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void mem_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = offset << p->regshift;
 	writeb(value, p->membase + offset);
 }
 
-static void mem16_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void mem16_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = offset << p->regshift;
 	writew(value, p->membase + offset);
 }
 
-static u32 mem16_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int mem16_serial_in(struct uart_port *p, int offset)
 {
 	offset = offset << p->regshift;
 	return readw(p->membase + offset);
 }
 
-static void mem32_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void mem32_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = offset << p->regshift;
 	writel(value, p->membase + offset);
 }
 
-static u32 mem32_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int mem32_serial_in(struct uart_port *p, int offset)
 {
 	offset = offset << p->regshift;
 	return readl(p->membase + offset);
 }
 
-static void mem32be_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void mem32be_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = offset << p->regshift;
 	iowrite32be(value, p->membase + offset);
 }
 
-static u32 mem32be_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int mem32be_serial_in(struct uart_port *p, int offset)
 {
 	offset = offset << p->regshift;
 	return ioread32be(p->membase + offset);
 }
 
 #ifdef CONFIG_HAS_IOPORT
-static u32 io_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int io_serial_in(struct uart_port *p, int offset)
 {
 	offset = offset << p->regshift;
 	return inb(p->iobase + offset);
 }
 
-static void io_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void io_serial_out(struct uart_port *p, int offset, int value)
 {
 	offset = offset << p->regshift;
 	outb(value, p->iobase + offset);
 }
 #endif
-static u32 no_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int no_serial_in(struct uart_port *p, int offset)
 {
-	return ~0U;
+	return (unsigned int)-1;
 }
 
-static void no_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void no_serial_out(struct uart_port *p, int offset, int value)
 {
 }
 
@@ -696,15 +705,6 @@ static void serial8250_set_sleep(struct uart_8250_port *p, int sleep)
 	serial8250_rpm_put(p);
 }
 
-/* Clear the interrupt registers. */
-static void serial8250_clear_interrupts(struct uart_port *port)
-{
-	serial_port_in(port, UART_LSR);
-	serial_port_in(port, UART_RX);
-	serial_port_in(port, UART_IIR);
-	serial_port_in(port, UART_MSR);
-}
-
 static void serial8250_clear_IER(struct uart_8250_port *up)
 {
 	if (up->capabilities & UART_CAP_UUE)
@@ -713,6 +713,75 @@ static void serial8250_clear_IER(struct uart_8250_port *up)
 		serial_out(up, UART_IER, 0);
 }
 
+#ifdef CONFIG_SERIAL_8250_RSA
+/*
+ * Attempts to turn on the RSA FIFO.  Returns zero on failure.
+ * We set the port uart clock rate if we succeed.
+ */
+static int __enable_rsa(struct uart_8250_port *up)
+{
+	unsigned char mode;
+	int result;
+
+	mode = serial_in(up, UART_RSA_MSR);
+	result = mode & UART_RSA_MSR_FIFO;
+
+	if (!result) {
+		serial_out(up, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);
+		mode = serial_in(up, UART_RSA_MSR);
+		result = mode & UART_RSA_MSR_FIFO;
+	}
+
+	if (result)
+		up->port.uartclk = SERIAL_RSA_BAUD_BASE * 16;
+
+	return result;
+}
+
+static void enable_rsa(struct uart_8250_port *up)
+{
+	if (up->port.type == PORT_RSA) {
+		if (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {
+			uart_port_lock_irq(&up->port);
+			__enable_rsa(up);
+			uart_port_unlock_irq(&up->port);
+		}
+		if (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)
+			serial_out(up, UART_RSA_FRR, 0);
+	}
+}
+
+/*
+ * Attempts to turn off the RSA FIFO.  Returns zero on failure.
+ * It is unknown why interrupts were disabled in here.  However,
+ * the caller is expected to preserve this behaviour by grabbing
+ * the spinlock before calling this function.
+ */
+static void disable_rsa(struct uart_8250_port *up)
+{
+	unsigned char mode;
+	int result;
+
+	if (up->port.type == PORT_RSA &&
+	    up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {
+		uart_port_lock_irq(&up->port);
+
+		mode = serial_in(up, UART_RSA_MSR);
+		result = !(mode & UART_RSA_MSR_FIFO);
+
+		if (!result) {
+			serial_out(up, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);
+			mode = serial_in(up, UART_RSA_MSR);
+			result = !(mode & UART_RSA_MSR_FIFO);
+		}
+
+		if (result)
+			up->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;
+		uart_port_unlock_irq(&up->port);
+	}
+}
+#endif /* CONFIG_SERIAL_8250_RSA */
+
 /*
  * This is a quickie test to see how big the FIFO is.
  * It doesn't work at all the time, more's the pity.
@@ -816,6 +885,8 @@ static void autoconfig_has_efr(struct uart_8250_port *up)
 	id3 = serial_icr_read(up, UART_ID3);
 	rev = serial_icr_read(up, UART_REV);
 
+	DEBUG_AUTOCONF("950id=%02x:%02x:%02x:%02x ", id1, id2, id3, rev);
+
 	if (id1 == 0x16 && id2 == 0xC9 &&
 	    (id3 == 0x50 || id3 == 0x52 || id3 == 0x54)) {
 		up->port.type = PORT_16C950;
@@ -839,6 +910,7 @@ static void autoconfig_has_efr(struct uart_8250_port *up)
 	 *  0x14 - XR16C854.
 	 */
 	id1 = autoconfig_read_divisor_id(up);
+	DEBUG_AUTOCONF("850id=%04x ", id1);
 
 	id2 = id1 >> 8;
 	if (id2 == 0x10 || id2 == 0x12 || id2 == 0x14) {
@@ -925,6 +997,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	if (serial_in(up, UART_EFR) == 0) {
 		serial_out(up, UART_EFR, 0xA8);
 		if (serial_in(up, UART_EFR) != 0) {
+			DEBUG_AUTOCONF("EFRv1 ");
 			up->port.type = PORT_16650;
 			up->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;
 		} else {
@@ -937,6 +1010,8 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 
 			if (status1 == UART_IIR_FIFO_ENABLED_16750)
 				up->port.type = PORT_16550A_FSL64;
+			else
+				DEBUG_AUTOCONF("Motorola 8xxx DUART ");
 		}
 		serial_out(up, UART_EFR, 0);
 		return;
@@ -948,6 +1023,7 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 	 */
 	serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 	if (serial_in(up, UART_EFR) == 0 && !broken_efr(up)) {
+		DEBUG_AUTOCONF("EFRv2 ");
 		autoconfig_has_efr(up);
 		return;
 	}
@@ -1010,6 +1086,8 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 
 	serial_out(up, UART_LCR, 0);
 
+	DEBUG_AUTOCONF("iir1=%d iir2=%d ", status1, status2);
+
 	if (status1 == UART_IIR_FIFO_ENABLED_16550A &&
 	    status2 == UART_IIR_FIFO_ENABLED_16750) {
 		up->port.type = PORT_16750;
@@ -1038,10 +1116,17 @@ static void autoconfig_16550a(struct uart_8250_port *up)
 			 * It's an Xscale.
 			 * We'll leave the UART_IER_UUE bit set to 1 (enabled).
 			 */
+			DEBUG_AUTOCONF("Xscale ");
 			up->port.type = PORT_XSCALE;
 			up->capabilities |= UART_CAP_UUE | UART_CAP_RTOIE;
 			return;
 		}
+	} else {
+		/*
+		 * If we got here we couldn't force the IER_UUE bit to 0.
+		 * Log it and continue.
+		 */
+		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
 	}
 	serial_out(up, UART_IER, iersave);
 
@@ -1073,6 +1158,9 @@ static void autoconfig(struct uart_8250_port *up)
 	if (!port->iobase && !port->mapbase && !port->membase)
 		return;
 
+	DEBUG_AUTOCONF("%s: autoconf (0x%04lx, 0x%p): ",
+		       port->name, port->iobase, port->membase);
+
 	/*
 	 * We really do need global IRQs disabled here - we're going to
 	 * be frobbing the chips IRQ enable register to see if it exists.
@@ -1119,7 +1207,9 @@ static void autoconfig(struct uart_8250_port *up)
 			 * We failed; there's nothing here
 			 */
 			uart_port_unlock_irqrestore(port, flags);
-			return;
+			DEBUG_AUTOCONF("IER test failed (%02x, %02x) ",
+				       scratch2, scratch3);
+			goto out;
 		}
 	}
 
@@ -1141,7 +1231,9 @@ static void autoconfig(struct uart_8250_port *up)
 		serial8250_out_MCR(up, save_mcr);
 		if (status1 != (UART_MSR_DCD | UART_MSR_CTS)) {
 			uart_port_unlock_irqrestore(port, flags);
-			return;
+			DEBUG_AUTOCONF("LOOP test failed (%02x) ",
+				       status1);
+			goto out;
 		}
 	}
 
@@ -1175,7 +1267,14 @@ static void autoconfig(struct uart_8250_port *up)
 		break;
 	}
 
-	rsa_autoconfig(up);
+#ifdef CONFIG_SERIAL_8250_RSA
+	/*
+	 * Only probe for RSA ports if we got the region.
+	 */
+	if (port->type == PORT_16550A && up->probe & UART_PROBE_RSA &&
+	    __enable_rsa(up))
+		port->type = PORT_RSA;
+#endif
 
 	serial_out(up, UART_LCR, save_lcr);
 
@@ -1184,17 +1283,22 @@ static void autoconfig(struct uart_8250_port *up)
 	up->capabilities = uart_config[port->type].flags;
 	up->tx_loadsz = uart_config[port->type].tx_loadsz;
 
-	if (port->type != PORT_UNKNOWN) {
-		/*
-		 * Reset the UART.
-		 */
-		rsa_reset(up);
-		serial8250_out_MCR(up, save_mcr);
-		serial8250_clear_fifos(up);
-		serial_in(up, UART_RX);
-		serial8250_clear_IER(up);
-	}
+	if (port->type == PORT_UNKNOWN)
+		goto out_unlock;
 
+	/*
+	 * Reset the UART.
+	 */
+#ifdef CONFIG_SERIAL_8250_RSA
+	if (port->type == PORT_RSA)
+		serial_out(up, UART_RSA_FRR, 0);
+#endif
+	serial8250_out_MCR(up, save_mcr);
+	serial8250_clear_fifos(up);
+	serial_in(up, UART_RX);
+	serial8250_clear_IER(up);
+
+out_unlock:
 	uart_port_unlock_irqrestore(port, flags);
 
 	/*
@@ -1207,6 +1311,9 @@ static void autoconfig(struct uart_8250_port *up)
 		dev_warn(port->dev, "detected caps %08x should be %08x\n",
 			 old_capabilities, up->capabilities);
 	}
+out:
+	DEBUG_AUTOCONF("iir=%d ", scratch);
+	DEBUG_AUTOCONF("type=%s\n", uart_config[port->type].name);
 }
 
 static void autoconfig_irq(struct uart_8250_port *up)
@@ -1247,7 +1354,10 @@ static void autoconfig_irq(struct uart_8250_port *up)
 	uart_port_lock_irq(port);
 	serial_out(up, UART_IER, UART_IER_ALL_INTR);
 	uart_port_unlock_irq(port);
-	serial8250_clear_interrupts(port);
+	serial_in(up, UART_LSR);
+	serial_in(up, UART_RX);
+	serial_in(up, UART_IIR);
+	serial_in(up, UART_MSR);
 	serial_out(up, UART_TX, 0xFF);
 	udelay(20);
 	irq = probe_irq_off(irqs);
@@ -2080,13 +2190,27 @@ static void serial8250_put_poll_char(struct uart_port *port,
 
 #endif /* CONFIG_CONSOLE_POLL */
 
-static void serial8250_startup_special(struct uart_port *port)
+int serial8250_do_startup(struct uart_port *port)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
 	unsigned long flags;
+	unsigned char iir;
+	int retval;
+	u16 lsr;
 
-	switch (port->type) {
-	case PORT_16C950:
+	if (!port->fifosize)
+		port->fifosize = uart_config[port->type].fifo_size;
+	if (!up->tx_loadsz)
+		up->tx_loadsz = uart_config[port->type].tx_loadsz;
+	if (!up->capabilities)
+		up->capabilities = uart_config[port->type].flags;
+	up->mcr = 0;
+
+	if (port->iotype != up->cur_iotype)
+		set_io_from_upio(port);
+
+	serial8250_rpm_get(up);
+	if (port->type == PORT_16C950) {
 		/*
 		 * Wake up and initialize UART
 		 *
@@ -2103,8 +2227,9 @@ static void serial8250_startup_special(struct uart_port *port)
 		serial_port_out(port, UART_EFR, UART_EFR_ECB);
 		serial_port_out(port, UART_LCR, 0);
 		uart_port_unlock_irqrestore(port, flags);
-		break;
-	case PORT_DA830:
+	}
+
+	if (port->type == PORT_DA830) {
 		/*
 		 * Reset the port
 		 *
@@ -2121,224 +2246,193 @@ static void serial8250_startup_special(struct uart_port *port)
 				UART_DA830_PWREMU_MGMT_UTRST |
 				UART_DA830_PWREMU_MGMT_URRST |
 				UART_DA830_PWREMU_MGMT_FREE);
-		break;
-	case PORT_RSA:
-		rsa_enable(up);
-		break;
 	}
-}
 
-static void serial8250_set_TRG_levels(struct uart_port *port)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
+#ifdef CONFIG_SERIAL_8250_RSA
+	/*
+	 * If this is an RSA port, see if we can kick it up to the
+	 * higher speed clock.
+	 */
+	enable_rsa(up);
+#endif
 
-	switch (port->type) {
-	/* For a XR16C850, we need to set the trigger levels */
-	case PORT_16850: {
-		u8 fctr;
+	/*
+	 * Clear the FIFO buffers and disable them.
+	 * (they will be reenabled in set_termios())
+	 */
+	serial8250_clear_fifos(up);
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	serial_port_in(port, UART_LSR);
+	serial_port_in(port, UART_RX);
+	serial_port_in(port, UART_IIR);
+	serial_port_in(port, UART_MSR);
+
+	/*
+	 * At this point, there's no way the LSR could still be 0xff;
+	 * if it is, then bail out, because there's likely no UART
+	 * here.
+	 */
+	if (!(port->flags & UPF_BUGGY_UART) &&
+	    (serial_port_in(port, UART_LSR) == 0xff)) {
+		dev_info_ratelimited(port->dev, "LSR safety check engaged!\n");
+		retval = -ENODEV;
+		goto out;
+	}
+
+	/*
+	 * For a XR16C850, we need to set the trigger levels
+	 */
+	if (port->type == PORT_16850) {
+		unsigned char fctr;
 
 		serial_out(up, UART_LCR, UART_LCR_CONF_MODE_B);
 
 		fctr = serial_in(up, UART_FCTR) & ~(UART_FCTR_RX|UART_FCTR_TX);
-		fctr |= UART_FCTR_TRGD;
-		serial_port_out(port, UART_FCTR, fctr | UART_FCTR_RX);
+		serial_port_out(port, UART_FCTR,
+				fctr | UART_FCTR_TRGD | UART_FCTR_RX);
 		serial_port_out(port, UART_TRG, UART_TRG_96);
-		serial_port_out(port, UART_FCTR, fctr | UART_FCTR_TX);
+		serial_port_out(port, UART_FCTR,
+				fctr | UART_FCTR_TRGD | UART_FCTR_TX);
 		serial_port_out(port, UART_TRG, UART_TRG_96);
 
 		serial_port_out(port, UART_LCR, 0);
-		break;
 	}
-	/* For the Altera 16550 variants, set TX threshold trigger level. */
-	case PORT_ALTR_16550_F32:
-	case PORT_ALTR_16550_F64:
-	case PORT_ALTR_16550_F128:
-		if (port->fifosize <= 1)
-			return;
 
+	/*
+	 * For the Altera 16550 variants, set TX threshold trigger level.
+	 */
+	if (((port->type == PORT_ALTR_16550_F32) ||
+	     (port->type == PORT_ALTR_16550_F64) ||
+	     (port->type == PORT_ALTR_16550_F128)) && (port->fifosize > 1)) {
 		/* Bounds checking of TX threshold (valid 0 to fifosize-2) */
-		if (up->tx_loadsz < 2 || up->tx_loadsz > port->fifosize) {
+		if ((up->tx_loadsz < 2) || (up->tx_loadsz > port->fifosize)) {
 			dev_err(port->dev, "TX FIFO Threshold errors, skipping\n");
-			return;
+		} else {
+			serial_port_out(port, UART_ALTR_AFR,
+					UART_ALTR_EN_TXFIFO_LW);
+			serial_port_out(port, UART_ALTR_TX_LOW,
+					port->fifosize - up->tx_loadsz);
+			port->handle_irq = serial8250_tx_threshold_handle_irq;
 		}
-		serial_port_out(port, UART_ALTR_AFR, UART_ALTR_EN_TXFIFO_LW);
-		serial_port_out(port, UART_ALTR_TX_LOW, port->fifosize - up->tx_loadsz);
-		port->handle_irq = serial8250_tx_threshold_handle_irq;
-		break;
 	}
-}
-
-static void serial8250_THRE_test(struct uart_port *port)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	unsigned long flags;
-	bool iir_noint1, iir_noint2;
-
-	if (!port->irq)
-		return;
-
-	if (up->port.flags & UPF_NO_THRE_TEST)
-		return;
 
-	if (port->irqflags & IRQF_SHARED)
-		disable_irq_nosync(port->irq);
-
-	/*
-	 * Test for UARTs that do not reassert THRE when the transmitter is idle and the interrupt
-	 * has already been cleared.  Real 16550s should always reassert this interrupt whenever the
-	 * transmitter is idle and the interrupt is enabled.  Delays are necessary to allow register
-	 * changes to become visible.
-	 *
-	 * Synchronize UART_IER access against the console.
-	 */
-	uart_port_lock_irqsave(port, &flags);
-
-	wait_for_xmitr(up, UART_LSR_THRE);
-	serial_port_out_sync(port, UART_IER, UART_IER_THRI);
-	udelay(1); /* allow THRE to set */
-	iir_noint1 = serial_port_in(port, UART_IIR) & UART_IIR_NO_INT;
-	serial_port_out(port, UART_IER, 0);
-	serial_port_out_sync(port, UART_IER, UART_IER_THRI);
-	udelay(1); /* allow a working UART time to re-assert THRE */
-	iir_noint2 = serial_port_in(port, UART_IIR) & UART_IIR_NO_INT;
-	serial_port_out(port, UART_IER, 0);
+	/* Check if we need to have shared IRQs */
+	if (port->irq && (up->port.flags & UPF_SHARE_IRQ))
+		up->port.irqflags |= IRQF_SHARED;
 
-	uart_port_unlock_irqrestore(port, flags);
+	retval = up->ops->setup_irq(up);
+	if (retval)
+		goto out;
 
-	if (port->irqflags & IRQF_SHARED)
-		enable_irq(port->irq);
+	if (port->irq && !(up->port.flags & UPF_NO_THRE_TEST)) {
+		unsigned char iir1;
 
-	/*
-	 * If the interrupt is not reasserted, or we otherwise don't trust the iir, setup a timer to
-	 * kick the UART on a regular basis.
-	 */
-	if ((!iir_noint1 && iir_noint2) || up->port.flags & UPF_BUG_THRE)
-		up->bugs |= UART_BUG_THRE;
-}
+		if (port->irqflags & IRQF_SHARED)
+			disable_irq_nosync(port->irq);
 
-static void serial8250_init_mctrl(struct uart_port *port)
-{
-	if (port->flags & UPF_FOURPORT) {
-		if (!port->irq)
-			port->mctrl |= TIOCM_OUT1;
-	} else {
-		/* Most PC uarts need OUT2 raised to enable interrupts. */
-		if (port->irq)
-			port->mctrl |= TIOCM_OUT2;
-	}
-
-	serial8250_set_mctrl(port, port->mctrl);
-}
+		/*
+		 * Test for UARTs that do not reassert THRE when the
+		 * transmitter is idle and the interrupt has already
+		 * been cleared.  Real 16550s should always reassert
+		 * this interrupt whenever the transmitter is idle and
+		 * the interrupt is enabled.  Delays are necessary to
+		 * allow register changes to become visible.
+		 *
+		 * Synchronize UART_IER access against the console.
+		 */
+		uart_port_lock_irqsave(port, &flags);
 
-static void serial8250_iir_txen_test(struct uart_port *port)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	bool lsr_temt, iir_noint;
+		wait_for_xmitr(up, UART_LSR_THRE);
+		serial_port_out_sync(port, UART_IER, UART_IER_THRI);
+		udelay(1); /* allow THRE to set */
+		iir1 = serial_port_in(port, UART_IIR);
+		serial_port_out(port, UART_IER, 0);
+		serial_port_out_sync(port, UART_IER, UART_IER_THRI);
+		udelay(1); /* allow a working UART time to re-assert THRE */
+		iir = serial_port_in(port, UART_IIR);
+		serial_port_out(port, UART_IER, 0);
 
-	if (port->quirks & UPQ_NO_TXEN_TEST)
-		return;
+		uart_port_unlock_irqrestore(port, flags);
 
-	/* Do a quick test to see if we receive an interrupt when we enable the TX irq. */
-	serial_port_out(port, UART_IER, UART_IER_THRI);
-	lsr_temt = serial_port_in(port, UART_LSR) & UART_LSR_TEMT;
-	iir_noint = serial_port_in(port, UART_IIR) & UART_IIR_NO_INT;
-	serial_port_out(port, UART_IER, 0);
+		if (port->irqflags & IRQF_SHARED)
+			enable_irq(port->irq);
 
-	/*
-	 * Serial over Lan (SoL) hack:
-	 * Intel 8257x Gigabit ethernet chips have a 16550 emulation, to be used for Serial Over
-	 * Lan.  Those chips take a longer time than a normal serial device to signalize that a
-	 * transmission data was queued. Due to that, the above test generally fails. One solution
-	 * would be to delay the reading of iir. However, this is not reliable, since the timeout is
-	 * variable. So, in case of UPQ_NO_TXEN_TEST, let's just don't test if we receive TX irq.
-	 * This way, we'll never enable UART_BUG_TXEN.
-	 */
-	if (lsr_temt && iir_noint) {
-		if (!(up->bugs & UART_BUG_TXEN)) {
-			up->bugs |= UART_BUG_TXEN;
-			dev_dbg(port->dev, "enabling bad tx status workarounds\n");
+		/*
+		 * If the interrupt is not reasserted, or we otherwise
+		 * don't trust the iir, setup a timer to kick the UART
+		 * on a regular basis.
+		 */
+		if ((!(iir1 & UART_IIR_NO_INT) && (iir & UART_IIR_NO_INT)) ||
+		    up->port.flags & UPF_BUG_THRE) {
+			up->bugs |= UART_BUG_THRE;
 		}
-		return;
 	}
 
-	/* FIXME: why is this needed? */
-	up->bugs &= ~UART_BUG_TXEN;
-}
-
-static void serial8250_initialize(struct uart_port *port)
-{
-	unsigned long flags;
+	up->ops->setup_timer(up);
 
-	uart_port_lock_irqsave(port, &flags);
+	/*
+	 * Now, initialize the UART
+	 */
 	serial_port_out(port, UART_LCR, UART_LCR_WLEN8);
 
-	serial8250_init_mctrl(port);
-	serial8250_iir_txen_test(port);
-	uart_port_unlock_irqrestore(port, flags);
-}
-
-int serial8250_do_startup(struct uart_port *port)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	int retval;
-
-	if (!port->fifosize)
-		port->fifosize = uart_config[port->type].fifo_size;
-	if (!up->tx_loadsz)
-		up->tx_loadsz = uart_config[port->type].tx_loadsz;
-	if (!up->capabilities)
-		up->capabilities = uart_config[port->type].flags;
-	up->mcr = 0;
-
-	if (port->iotype != up->cur_iotype)
-		set_io_from_upio(port);
-
-	serial8250_rpm_get(up);
+	uart_port_lock_irqsave(port, &flags);
+	if (up->port.flags & UPF_FOURPORT) {
+		if (!up->port.irq)
+			up->port.mctrl |= TIOCM_OUT1;
+	} else
+		/*
+		 * Most PC uarts need OUT2 raised to enable interrupts.
+		 */
+		if (port->irq)
+			up->port.mctrl |= TIOCM_OUT2;
 
-	serial8250_startup_special(port);
+	serial8250_set_mctrl(port, port->mctrl);
 
 	/*
-	 * Clear the FIFO buffers and disable them.
-	 * (they will be reenabled in set_termios())
+	 * Serial over Lan (SoL) hack:
+	 * Intel 8257x Gigabit ethernet chips have a 16550 emulation, to be
+	 * used for Serial Over Lan.  Those chips take a longer time than a
+	 * normal serial device to signalize that a transmission data was
+	 * queued. Due to that, the above test generally fails. One solution
+	 * would be to delay the reading of iir. However, this is not
+	 * reliable, since the timeout is variable. So, let's just don't
+	 * test if we receive TX irq.  This way, we'll never enable
+	 * UART_BUG_TXEN.
 	 */
-	serial8250_clear_fifos(up);
-
-	serial8250_clear_interrupts(port);
+	if (!(up->port.quirks & UPQ_NO_TXEN_TEST)) {
+		/*
+		 * Do a quick test to see if we receive an interrupt when we
+		 * enable the TX irq.
+		 */
+		serial_port_out(port, UART_IER, UART_IER_THRI);
+		lsr = serial_port_in(port, UART_LSR);
+		iir = serial_port_in(port, UART_IIR);
+		serial_port_out(port, UART_IER, 0);
 
-	/*
-	 * At this point, there's no way the LSR could still be 0xff;
-	 * if it is, then bail out, because there's likely no UART
-	 * here.
-	 */
-	if (!(port->flags & UPF_BUGGY_UART) &&
-	    (serial_port_in(port, UART_LSR) == 0xff)) {
-		dev_info_ratelimited(port->dev, "LSR safety check engaged!\n");
-		retval = -ENODEV;
-		goto out;
+		if (lsr & UART_LSR_TEMT && iir & UART_IIR_NO_INT) {
+			if (!(up->bugs & UART_BUG_TXEN)) {
+				up->bugs |= UART_BUG_TXEN;
+				dev_dbg(port->dev, "enabling bad tx status workarounds\n");
+			}
+		} else {
+			up->bugs &= ~UART_BUG_TXEN;
+		}
 	}
 
-	serial8250_set_TRG_levels(port);
-
-	/* Check if we need to have shared IRQs */
-	if (port->irq && (up->port.flags & UPF_SHARE_IRQ))
-		up->port.irqflags |= IRQF_SHARED;
-
-	retval = up->ops->setup_irq(up);
-	if (retval)
-		goto out;
-
-	serial8250_THRE_test(port);
-
-	up->ops->setup_timer(up);
-
-	serial8250_initialize(port);
+	uart_port_unlock_irqrestore(port, flags);
 
 	/*
 	 * Clear the interrupt registers again for luck, and clear the
 	 * saved flags to avoid getting false values from polling
 	 * routines or the previous session.
 	 */
-	serial8250_clear_interrupts(port);
+	serial_port_in(port, UART_LSR);
+	serial_port_in(port, UART_RX);
+	serial_port_in(port, UART_IIR);
+	serial_port_in(port, UART_MSR);
 	up->lsr_saved_flags = 0;
 	up->msr_saved_flags = 0;
 
@@ -2427,7 +2521,12 @@ void serial8250_do_shutdown(struct uart_port *port)
 			serial_port_in(port, UART_LCR) & ~UART_LCR_SBC);
 	serial8250_clear_fifos(up);
 
-	rsa_disable(up);
+#ifdef CONFIG_SERIAL_8250_RSA
+	/*
+	 * Reset the RSA board back to 115kbps compat mode.
+	 */
+	disable_rsa(up);
+#endif
 
 	/*
 	 * Read data port to reset things, and then unlink from
@@ -2456,7 +2555,9 @@ static void serial8250_flush_buffer(struct uart_port *port)
 		serial8250_tx_dma_flush(up);
 }
 
-static unsigned int serial8250_do_get_divisor(struct uart_port *port, unsigned int baud)
+static unsigned int serial8250_do_get_divisor(struct uart_port *port,
+					      unsigned int baud,
+					      unsigned int *frac)
 {
 	upf_t magic_multiplier = port->flags & UPF_MAGIC_MULTIPLIER;
 	struct uart_8250_port *up = up_to_u8250p(port);
@@ -2517,23 +2618,26 @@ static unsigned int serial8250_get_divisor(struct uart_port *port,
 	if (port->get_divisor)
 		return port->get_divisor(port, baud, frac);
 
-	return serial8250_do_get_divisor(port, baud);
+	return serial8250_do_get_divisor(port, baud, frac);
 }
 
-static unsigned char serial8250_compute_lcr(struct uart_8250_port *up, tcflag_t c_cflag)
+static unsigned char serial8250_compute_lcr(struct uart_8250_port *up,
+					    tcflag_t c_cflag)
 {
-	u8 lcr = UART_LCR_WLEN(tty_get_char_size(c_cflag));
+	unsigned char cval;
+
+	cval = UART_LCR_WLEN(tty_get_char_size(c_cflag));
 
 	if (c_cflag & CSTOPB)
-		lcr |= UART_LCR_STOP;
+		cval |= UART_LCR_STOP;
 	if (c_cflag & PARENB)
-		lcr |= UART_LCR_PARITY;
+		cval |= UART_LCR_PARITY;
 	if (!(c_cflag & PARODD))
-		lcr |= UART_LCR_EPAR;
+		cval |= UART_LCR_EPAR;
 	if (c_cflag & CMSPAR)
-		lcr |= UART_LCR_SPAR;
+		cval |= UART_LCR_SPAR;
 
-	return lcr;
+	return cval;
 }
 
 void serial8250_do_set_divisor(struct uart_port *port, unsigned int baud,
@@ -2640,62 +2744,65 @@ void serial8250_update_uartclk(struct uart_port *port, unsigned int uartclk)
 }
 EXPORT_SYMBOL_GPL(serial8250_update_uartclk);
 
-static void serial8250_set_mini(struct uart_port *port, struct ktermios *termios)
+void
+serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
+		          const struct ktermios *old)
 {
 	struct uart_8250_port *up = up_to_u8250p(port);
+	unsigned char cval;
+	unsigned long flags;
+	unsigned int baud, quot, frac = 0;
 
-	if (!(up->capabilities & UART_CAP_MINI))
-		return;
-
-	termios->c_cflag &= ~(CSTOPB | PARENB | PARODD | CMSPAR);
-
-	tcflag_t csize = termios->c_cflag & CSIZE;
-	if (csize == CS5 || csize == CS6) {
-		termios->c_cflag &= ~CSIZE;
-		termios->c_cflag |= CS7;
+	if (up->capabilities & UART_CAP_MINI) {
+		termios->c_cflag &= ~(CSTOPB | PARENB | PARODD | CMSPAR);
+		if ((termios->c_cflag & CSIZE) == CS5 ||
+		    (termios->c_cflag & CSIZE) == CS6)
+			termios->c_cflag = (termios->c_cflag & ~CSIZE) | CS7;
 	}
-}
+	cval = serial8250_compute_lcr(up, termios->c_cflag);
 
-static void serial8250_set_trigger_for_slow_speed(struct uart_port *port, struct ktermios *termios,
-						  unsigned int baud)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
+	baud = serial8250_get_baud_rate(port, termios, old);
+	quot = serial8250_get_divisor(port, baud, &frac);
 
-	if (!(up->capabilities & UART_CAP_FIFO))
-		return;
-	if (port->fifosize <= 1)
-		return;
-	if (baud >= 2400)
-		return;
-	if (up->dma)
-		return;
+	/*
+	 * Ok, we're now changing the port state.  Do it with
+	 * interrupts disabled.
+	 *
+	 * Synchronize UART_IER access against the console.
+	 */
+	serial8250_rpm_get(up);
+	uart_port_lock_irqsave(port, &flags);
 
-	up->fcr &= ~UART_FCR_TRIGGER_MASK;
-	up->fcr |= UART_FCR_TRIGGER_1;
-}
+	up->lcr = cval;					/* Save computed LCR */
 
-/*
- * MCR-based auto flow control. When AFE is enabled, RTS will be deasserted when the receive FIFO
- * contains more characters than the trigger, or the MCR RTS bit is cleared.
- */
-static void serial8250_set_afe(struct uart_port *port, struct ktermios *termios)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
+	if (up->capabilities & UART_CAP_FIFO && port->fifosize > 1) {
+		if (baud < 2400 && !up->dma) {
+			up->fcr &= ~UART_FCR_TRIGGER_MASK;
+			up->fcr |= UART_FCR_TRIGGER_1;
+		}
+	}
 
-	if (!(up->capabilities & UART_CAP_AFE))
-		return;
+	/*
+	 * MCR-based auto flow control.  When AFE is enabled, RTS will be
+	 * deasserted when the receive FIFO contains more characters than
+	 * the trigger, or the MCR RTS bit is cleared.
+	 */
+	if (up->capabilities & UART_CAP_AFE) {
+		up->mcr &= ~UART_MCR_AFE;
+		if (termios->c_cflag & CRTSCTS)
+			up->mcr |= UART_MCR_AFE;
+	}
 
-	up->mcr &= ~UART_MCR_AFE;
-	if (termios->c_cflag & CRTSCTS)
-		up->mcr |= UART_MCR_AFE;
-}
+	/*
+	 * Update the per-port timeout.
+	 */
+	uart_update_timeout(port, termios->c_cflag, baud);
 
-static void serial8250_set_errors_and_ignores(struct uart_port *port, struct ktermios *termios)
-{
 	/*
-	 * Specify which conditions may be considered for error handling and the ignoring of
-	 * characters. The actual ignoring of characters only occurs if the bit is set in
-	 * @ignore_status_mask as well.
+	 * Specify which conditions may be considered for error
+	 * handling and the ignoring of characters. The actual
+	 * ignoring of characters only occurs if the bit is set
+	 * in @ignore_status_mask as well.
 	 */
 	port->read_status_mask = UART_LSR_OE | UART_LSR_DR;
 	if (termios->c_iflag & INPCK)
@@ -2703,32 +2810,34 @@ static void serial8250_set_errors_and_ignores(struct uart_port *port, struct kte
 	if (termios->c_iflag & (IGNBRK | BRKINT | PARMRK))
 		port->read_status_mask |= UART_LSR_BI;
 
-	/* Characters to ignore */
+	/*
+	 * Characters to ignore
+	 */
 	port->ignore_status_mask = 0;
 	if (termios->c_iflag & IGNPAR)
 		port->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
 	if (termios->c_iflag & IGNBRK) {
 		port->ignore_status_mask |= UART_LSR_BI;
 		/*
-		 * If we're ignoring parity and break indicators, ignore overruns too (for real raw
-		 * support).
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns too (for real raw support).
 		 */
 		if (termios->c_iflag & IGNPAR)
 			port->ignore_status_mask |= UART_LSR_OE;
 	}
 
-	/* ignore all characters if CREAD is not set */
+	/*
+	 * ignore all characters if CREAD is not set
+	 */
 	if ((termios->c_cflag & CREAD) == 0)
 		port->ignore_status_mask |= UART_LSR_DR;
-}
 
-static void serial8250_set_ier(struct uart_port *port, struct ktermios *termios)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-
-	/* CTS flow control flag and modem status interrupts */
+	/*
+	 * CTS flow control flag and modem status interrupts
+	 */
 	up->ier &= ~UART_IER_MSI;
-	if (!(up->bugs & UART_BUG_NOMSR) && UART_ENABLE_MS(&up->port, termios->c_cflag))
+	if (!(up->bugs & UART_BUG_NOMSR) &&
+			UART_ENABLE_MS(&up->port, termios->c_cflag))
 		up->ier |= UART_IER_MSI;
 	if (up->capabilities & UART_CAP_UUE)
 		up->ier |= UART_IER_UUE;
@@ -2736,90 +2845,41 @@ static void serial8250_set_ier(struct uart_port *port, struct ktermios *termios)
 		up->ier |= UART_IER_RTOIE;
 
 	serial_port_out(port, UART_IER, up->ier);
-}
-
-static void serial8250_set_efr(struct uart_port *port, struct ktermios *termios)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	u8 efr_reg = UART_EFR;
-	u8 efr = 0;
-
-	if (!(up->capabilities & UART_CAP_EFR))
-		return;
 
-	/*
-	 * TI16C752/Startech hardware flow control.  FIXME:
-	 * - TI16C752 requires control thresholds to be set.
-	 * - UART_MCR_RTS is ineffective if auto-RTS mode is enabled.
-	 */
-	if (termios->c_cflag & CRTSCTS)
-		efr |= UART_EFR_CTS;
-
-	if (port->flags & UPF_EXAR_EFR)
-		efr_reg = UART_XR_EFR;
-
-	serial_port_out(port, UART_LCR, UART_LCR_CONF_MODE_B);
-	serial_port_out(port, efr_reg, efr);
-}
-
-static void serial8250_set_fcr(struct uart_port *port, struct ktermios *termios)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	bool is_16750 = port->type == PORT_16750;
-
-	if (is_16750)
-		serial_port_out(port, UART_FCR, up->fcr);
-
-	/*
-	 * LCR DLAB must be reset to enable 64-byte FIFO mode. If the FCR is written without DLAB
-	 * set, this mode will be disabled.
-	 */
-	serial_port_out(port, UART_LCR, up->lcr);
-
-	if (is_16750)
-		return;
-
-	/* emulated UARTs (Lucent Venus 167x) need two steps */
-	if (up->fcr & UART_FCR_ENABLE_FIFO)
-		serial_port_out(port, UART_FCR, UART_FCR_ENABLE_FIFO);
-
-	serial_port_out(port, UART_FCR, up->fcr);
-}
+	if (up->capabilities & UART_CAP_EFR) {
+		unsigned char efr = 0;
+		/*
+		 * TI16C752/Startech hardware flow control.  FIXME:
+		 * - TI16C752 requires control thresholds to be set.
+		 * - UART_MCR_RTS is ineffective if auto-RTS mode is enabled.
+		 */
+		if (termios->c_cflag & CRTSCTS)
+			efr |= UART_EFR_CTS;
 
-void
-serial8250_do_set_termios(struct uart_port *port, struct ktermios *termios,
-		          const struct ktermios *old)
-{
-	struct uart_8250_port *up = up_to_u8250p(port);
-	unsigned long flags;
-	unsigned int baud, quot, frac = 0;
-	u8 lcr;
+		serial_port_out(port, UART_LCR, UART_LCR_CONF_MODE_B);
+		if (port->flags & UPF_EXAR_EFR)
+			serial_port_out(port, UART_XR_EFR, efr);
+		else
+			serial_port_out(port, UART_EFR, efr);
+	}
 
-	serial8250_set_mini(port, termios);
-	lcr = serial8250_compute_lcr(up, termios->c_cflag);
-	baud = serial8250_get_baud_rate(port, termios, old);
-	quot = serial8250_get_divisor(port, baud, &frac);
+	serial8250_set_divisor(port, baud, quot, frac);
 
 	/*
-	 * Ok, we're now changing the port state.  Do it with
-	 * interrupts disabled.
-	 *
-	 * Synchronize UART_IER access against the console.
+	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
+	 * is written without DLAB set, this mode will be disabled.
 	 */
-	serial8250_rpm_get(up);
-	uart_port_lock_irqsave(port, &flags);
+	if (port->type == PORT_16750)
+		serial_port_out(port, UART_FCR, up->fcr);
 
-	up->lcr = lcr;
-	serial8250_set_trigger_for_slow_speed(port, termios, baud);
-	serial8250_set_afe(port, termios);
-	uart_update_timeout(port, termios->c_cflag, baud);
-	serial8250_set_errors_and_ignores(port, termios);
-	serial8250_set_ier(port, termios);
-	serial8250_set_efr(port, termios);
-	serial8250_set_divisor(port, baud, quot, frac);
-	serial8250_set_fcr(port, termios);
+	serial_port_out(port, UART_LCR, up->lcr);	/* reset DLAB */
+	if (port->type != PORT_16750) {
+		/* emulated UARTs (Lucent Venus 167x) need two steps */
+		if (up->fcr & UART_FCR_ENABLE_FIFO)
+			serial_port_out(port, UART_FCR, UART_FCR_ENABLE_FIFO);
+		serial_port_out(port, UART_FCR, up->fcr);	/* set fcr */
+	}
 	serial8250_set_mctrl(port, port->mctrl);
-
 	uart_port_unlock_irqrestore(port, flags);
 	serial8250_rpm_put(up);
 
diff --git a/drivers/tty/serial/8250/8250_rsa.c b/drivers/tty/serial/8250/8250_rsa.c
index d34093cc03ad9..4c8b9671bd41d 100644
--- a/drivers/tty/serial/8250/8250_rsa.c
+++ b/drivers/tty/serial/8250/8250_rsa.c
@@ -107,102 +107,6 @@ void univ8250_rsa_support(struct uart_ops *ops)
 module_param_hw_array(probe_rsa, ulong, ioport, &probe_rsa_count, 0444);
 MODULE_PARM_DESC(probe_rsa, "Probe I/O ports for RSA");
 
-/*
- * Attempts to turn on the RSA FIFO.  Returns zero on failure.
- * We set the port uart clock rate if we succeed.
- */
-static int __rsa_enable(struct uart_8250_port *up)
-{
-	unsigned char mode;
-	int result;
-
-	mode = serial_in(up, UART_RSA_MSR);
-	result = mode & UART_RSA_MSR_FIFO;
-
-	if (!result) {
-		serial_out(up, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);
-		mode = serial_in(up, UART_RSA_MSR);
-		result = mode & UART_RSA_MSR_FIFO;
-	}
-
-	if (result)
-		up->port.uartclk = SERIAL_RSA_BAUD_BASE * 16;
-
-	return result;
-}
-
-/*
- * If this is an RSA port, see if we can kick it up to the higher speed clock.
- */
-void rsa_enable(struct uart_8250_port *up)
-{
-	if (up->port.type != PORT_RSA)
-		return;
-
-	if (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {
-		uart_port_lock_irq(&up->port);
-		__rsa_enable(up);
-		uart_port_unlock_irq(&up->port);
-	}
-	if (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)
-		serial_out(up, UART_RSA_FRR, 0);
-}
-EXPORT_SYMBOL_GPL_FOR_MODULES(rsa_enable, "8250_base");
-
-/*
- * Attempts to turn off the RSA FIFO and resets the RSA board back to 115kbps compat mode. It is
- * unknown why interrupts were disabled in here. However, the caller is expected to preserve this
- * behaviour by grabbing the spinlock before calling this function.
- */
-void rsa_disable(struct uart_8250_port *up)
-{
-	unsigned char mode;
-	int result;
-
-	if (up->port.type != PORT_RSA)
-		return;
-
-	if (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16)
-		return;
-
-	uart_port_lock_irq(&up->port);
-	mode = serial_in(up, UART_RSA_MSR);
-	result = !(mode & UART_RSA_MSR_FIFO);
-
-	if (!result) {
-		serial_out(up, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);
-		mode = serial_in(up, UART_RSA_MSR);
-		result = !(mode & UART_RSA_MSR_FIFO);
-	}
-
-	if (result)
-		up->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;
-	uart_port_unlock_irq(&up->port);
-}
-EXPORT_SYMBOL_GPL_FOR_MODULES(rsa_disable, "8250_base");
-
-void rsa_autoconfig(struct uart_8250_port *up)
-{
-	/* Only probe for RSA ports if we got the region. */
-	if (up->port.type != PORT_16550A)
-		return;
-	if (!(up->probe & UART_PROBE_RSA))
-		return;
-
-	if (__rsa_enable(up))
-		up->port.type = PORT_RSA;
-}
-EXPORT_SYMBOL_GPL_FOR_MODULES(rsa_autoconfig, "8250_base");
-
-void rsa_reset(struct uart_8250_port *up)
-{
-	if (up->port.type != PORT_RSA)
-		return;
-
-	serial_out(up, UART_RSA_FRR, 0);
-}
-EXPORT_SYMBOL_GPL_FOR_MODULES(rsa_reset, "8250_base");
-
 #ifdef CONFIG_SERIAL_8250_DEPRECATED_OPTIONS
 #ifndef MODULE
 /*
diff --git a/drivers/tty/serial/8250/8250_rt288x.c b/drivers/tty/serial/8250/8250_rt288x.c
index bf28b8a9a7102..6415ca8d3adff 100644
--- a/drivers/tty/serial/8250/8250_rt288x.c
+++ b/drivers/tty/serial/8250/8250_rt288x.c
@@ -33,7 +33,7 @@ static const u8 au_io_out_map[5] = {
 	[UART_MCR]	= 6,
 };
 
-static u32 au_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int au_serial_in(struct uart_port *p, int offset)
 {
 	if (offset >= ARRAY_SIZE(au_io_in_map))
 		return UINT_MAX;
@@ -42,7 +42,7 @@ static u32 au_serial_in(struct uart_port *p, unsigned int offset)
 	return __raw_readl(p->membase + (offset << p->regshift));
 }
 
-static void au_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void au_serial_out(struct uart_port *p, int offset, int value)
 {
 	if (offset >= ARRAY_SIZE(au_io_out_map))
 		return;
diff --git a/drivers/tty/serial/8250/8250_uniphier.c b/drivers/tty/serial/8250/8250_uniphier.c
index e3db60bf50c93..4874a9632db39 100644
--- a/drivers/tty/serial/8250/8250_uniphier.c
+++ b/drivers/tty/serial/8250/8250_uniphier.c
@@ -63,7 +63,7 @@ OF_EARLYCON_DECLARE(uniphier, "socionext,uniphier-uart",
  * The register map is slightly different from that of 8250.
  * IO callbacks must be overridden for correct access to FCR, LCR, MCR and SCR.
  */
-static u32 uniphier_serial_in(struct uart_port *p, unsigned int offset)
+static unsigned int uniphier_serial_in(struct uart_port *p, int offset)
 {
 	unsigned int valshift = 0;
 
@@ -92,7 +92,7 @@ static u32 uniphier_serial_in(struct uart_port *p, unsigned int offset)
 	return (readl(p->membase + offset) >> valshift) & 0xff;
 }
 
-static void uniphier_serial_out(struct uart_port *p, unsigned int offset, u32 value)
+static void uniphier_serial_out(struct uart_port *p, int offset, int value)
 {
 	unsigned int valshift = 0;
 	bool normal = false;
diff --git a/drivers/tty/serial/8250/Makefile b/drivers/tty/serial/8250/Makefile
index 513a0941c284f..b04eeda03b234 100644
--- a/drivers/tty/serial/8250/Makefile
+++ b/drivers/tty/serial/8250/Makefile
@@ -24,9 +24,6 @@ obj-$(CONFIG_SERIAL_8250_ASPEED_VUART)	+= 8250_aspeed_vuart.o
 obj-$(CONFIG_SERIAL_8250_BCM2835AUX)	+= 8250_bcm2835aux.o
 obj-$(CONFIG_SERIAL_8250_BCM7271)	+= 8250_bcm7271.o
 obj-$(CONFIG_SERIAL_8250_BOCA)		+= 8250_boca.o
-ifeq ($(CONFIG_SERIAL_8250),y)
-obj-$(CONFIG_X86_INTEL_CE)		+= 8250_ce4100.o
-endif
 obj-$(CONFIG_SERIAL_8250_DFL)		+= 8250_dfl.o
 obj-$(CONFIG_SERIAL_8250_DW)		+= 8250_dw.o
 obj-$(CONFIG_SERIAL_8250_EM)		+= 8250_em.o
diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig
index 44427415a80d7..79a8186d33613 100644
--- a/drivers/tty/serial/Kconfig
+++ b/drivers/tty/serial/Kconfig
@@ -675,13 +675,6 @@ config SERIAL_SH_SCI_DMA
 	depends on SERIAL_SH_SCI && DMA_ENGINE
 	default ARCH_RENESAS
 
-config SERIAL_RSCI
-	tristate "Support for Renesas RZ/T2H SCI variant"
-	depends on SERIAL_SH_SCI
-	help
-	  Support for the RZ/T2H SCI variant with fifo.
-	  Say Y if you want to be able to use the RZ/T2H SCI serial port.
-
 config SERIAL_HS_LPC32XX
 	tristate "LPC32XX high speed serial port support"
 	depends on ARCH_LPC32XX || COMPILE_TEST
diff --git a/drivers/tty/serial/Makefile b/drivers/tty/serial/Makefile
index a2ccbc508ec57..d58d9f719889d 100644
--- a/drivers/tty/serial/Makefile
+++ b/drivers/tty/serial/Makefile
@@ -71,7 +71,6 @@ obj-$(CONFIG_SERIAL_QCOM_GENI)		+= qcom_geni_serial.o
 obj-$(CONFIG_SERIAL_QE)			+= ucc_uart.o
 obj-$(CONFIG_SERIAL_RDA)		+= rda-uart.o
 obj-$(CONFIG_SERIAL_RP2)		+= rp2.o
-obj-$(CONFIG_SERIAL_RSCI)		+= rsci.o
 obj-$(CONFIG_SERIAL_SA1100)		+= sa1100.o
 obj-$(CONFIG_SERIAL_SAMSUNG)		+= samsung_tty.o
 obj-$(CONFIG_SERIAL_SB1250_DUART)	+= sb1250-duart.o
diff --git a/drivers/tty/serial/fsl_lpuart.c b/drivers/tty/serial/fsl_lpuart.c
index c9519e649e826..2790b4078e7ed 100644
--- a/drivers/tty/serial/fsl_lpuart.c
+++ b/drivers/tty/serial/fsl_lpuart.c
@@ -318,27 +318,27 @@ static const struct lpuart_soc_data ls1028a_data = {
 	.rx_watermark = 0,
 };
 
-static const struct lpuart_soc_data imx7ulp_data = {
+static struct lpuart_soc_data imx7ulp_data = {
 	.devtype = IMX7ULP_LPUART,
 	.iotype = UPIO_MEM32,
 	.reg_off = IMX_REG_OFF,
 	.rx_watermark = 1,
 };
 
-static const struct lpuart_soc_data imx8ulp_data = {
+static struct lpuart_soc_data imx8ulp_data = {
 	.devtype = IMX8ULP_LPUART,
 	.iotype = UPIO_MEM32,
 	.reg_off = IMX_REG_OFF,
 	.rx_watermark = 3,
 };
 
-static const struct lpuart_soc_data imx8qxp_data = {
+static struct lpuart_soc_data imx8qxp_data = {
 	.devtype = IMX8QXP_LPUART,
 	.iotype = UPIO_MEM32,
 	.reg_off = IMX_REG_OFF,
 	.rx_watermark = 7, /* A lower watermark is ideal for low baud rates. */
 };
-static const struct lpuart_soc_data imxrt1050_data = {
+static struct lpuart_soc_data imxrt1050_data = {
 	.devtype = IMXRT1050_LPUART,
 	.iotype = UPIO_MEM32,
 	.reg_off = IMX_REG_OFF,
diff --git a/drivers/tty/serial/qcom_geni_serial.c b/drivers/tty/serial/qcom_geni_serial.c
index 32ec632fd0807..0293b6210aa67 100644
--- a/drivers/tty/serial/qcom_geni_serial.c
+++ b/drivers/tty/serial/qcom_geni_serial.c
@@ -11,7 +11,6 @@
 #include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/of.h>
-#include <linux/pm_domain.h>
 #include <linux/pm_opp.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
@@ -100,16 +99,10 @@
 #define DMA_RX_BUF_SIZE		2048
 
 static DEFINE_IDA(port_ida);
-#define DOMAIN_IDX_POWER	0
-#define DOMAIN_IDX_PERF		1
 
 struct qcom_geni_device_data {
 	bool console;
 	enum geni_se_xfer_mode mode;
-	struct dev_pm_domain_attach_data pd_data;
-	int (*resources_init)(struct uart_port *uport);
-	int (*set_rate)(struct uart_port *uport, unsigned int baud);
-	int (*power_state)(struct uart_port *uport, bool state);
 };
 
 struct qcom_geni_private_data {
@@ -147,7 +140,6 @@ struct qcom_geni_serial_port {
 
 	struct qcom_geni_private_data private_data;
 	const struct qcom_geni_device_data *dev_data;
-	struct dev_pm_domain_list *pd_list;
 };
 
 static const struct uart_ops qcom_geni_console_pops;
@@ -200,33 +192,6 @@ static struct qcom_geni_serial_port qcom_geni_console_port = {
 	},
 };
 
-static const struct serial_rs485 qcom_geni_rs485_supported = {
-	.flags = SER_RS485_ENABLED | SER_RS485_RTS_AFTER_SEND | SER_RS485_RTS_ON_SEND,
-};
-
-/**
- * qcom_geni_set_rs485_mode - Set RTS pin state for RS485 mode
- * @uport: UART port
- * @flag: RS485 flag to determine RTS polarity
- *
- * Enables manual RTS control for RS485. Sets RTS to READY or NOT_READY
- * based on the specified flag if RS485 mode is enabled.
- */
-static void qcom_geni_set_rs485_mode(struct uart_port *uport, u32 flag)
-{
-	if (!(uport->rs485.flags & SER_RS485_ENABLED))
-		return;
-
-	u32 rfr = UART_MANUAL_RFR_EN;
-
-	if (uport->rs485.flags & flag)
-		rfr |= UART_RFR_NOT_READY;
-	else
-		rfr |= UART_RFR_READY;
-
-	writel(rfr, uport->membase + SE_UART_MANUAL_RFR);
-}
-
 static int qcom_geni_serial_request_port(struct uart_port *uport)
 {
 	struct platform_device *pdev = to_platform_device(uport->dev);
@@ -699,8 +664,6 @@ static void qcom_geni_serial_start_tx_dma(struct uart_port *uport)
 	xmit_size = kfifo_out_linear_ptr(&tport->xmit_fifo, &tail,
 			UART_XMIT_SIZE);
 
-	qcom_geni_set_rs485_mode(uport, SER_RS485_RTS_ON_SEND);
-
 	qcom_geni_serial_setup_tx(uport, xmit_size);
 
 	ret = geni_se_tx_dma_prep(&port->se, tail, xmit_size,
@@ -1108,10 +1071,8 @@ static irqreturn_t qcom_geni_serial_isr(int isr, void *dev)
 	}
 
 	if (dma) {
-		if (dma_tx_status & TX_DMA_DONE) {
+		if (dma_tx_status & TX_DMA_DONE)
 			qcom_geni_serial_handle_tx_dma(uport);
-			qcom_geni_set_rs485_mode(uport, SER_RS485_RTS_AFTER_SEND);
-	}
 
 		if (dma_rx_status) {
 			if (dma_rx_status & RX_RESET_DONE)
@@ -1322,14 +1283,27 @@ static unsigned long get_clk_div_rate(struct clk *clk, unsigned int baud,
 	return ser_clk;
 }
 
-static int geni_serial_set_rate(struct uart_port *uport, unsigned int baud)
+static void qcom_geni_serial_set_termios(struct uart_port *uport,
+					 struct ktermios *termios,
+					 const struct ktermios *old)
 {
+	unsigned int baud;
+	u32 bits_per_char;
+	u32 tx_trans_cfg;
+	u32 tx_parity_cfg;
+	u32 rx_trans_cfg;
+	u32 rx_parity_cfg;
+	u32 stop_bit_len;
+	unsigned int clk_div;
+	u32 ser_clk_cfg;
 	struct qcom_geni_serial_port *port = to_dev_port(uport);
 	unsigned long clk_rate;
-	unsigned int avg_bw_core;
-	unsigned int clk_div;
 	u32 ver, sampling_rate;
-	u32 ser_clk_cfg;
+	unsigned int avg_bw_core;
+	unsigned long timeout;
+
+	/* baud rate */
+	baud = uart_get_baud_rate(uport, termios, old, 300, 4000000);
 
 	sampling_rate = UART_OVERSAMPLING;
 	/* Sampling rate is halved for IP versions >= 2.5 */
@@ -1343,7 +1317,7 @@ static int geni_serial_set_rate(struct uart_port *uport, unsigned int baud)
 		dev_err(port->se.dev,
 			"Couldn't find suitable clock rate for %u\n",
 			baud * sampling_rate);
-		return -EINVAL;
+		return;
 	}
 
 	dev_dbg(port->se.dev, "desired_rate = %u, clk_rate = %lu, clk_div = %u\n",
@@ -1365,69 +1339,6 @@ static int geni_serial_set_rate(struct uart_port *uport, unsigned int baud)
 	port->se.icc_paths[CPU_TO_GENI].avg_bw = Bps_to_icc(baud);
 	geni_icc_set_bw(&port->se);
 
-	writel(ser_clk_cfg, uport->membase + GENI_SER_M_CLK_CFG);
-	writel(ser_clk_cfg, uport->membase + GENI_SER_S_CLK_CFG);
-	return 0;
-}
-
-static int geni_serial_set_level(struct uart_port *uport, unsigned int baud)
-{
-	struct qcom_geni_serial_port *port = to_dev_port(uport);
-	struct device *perf_dev = port->pd_list->pd_devs[DOMAIN_IDX_PERF];
-
-	/*
-	 * The performance protocol sets UART communication
-	 * speeds by selecting different performance levels
-	 * through the OPP framework.
-	 *
-	 * Supported perf levels for baudrates in firmware are below
-	 * +---------------------+--------------------+
-	 * |  Perf level value   |  Baudrate values   |
-	 * +---------------------+--------------------+
-	 * |      300            |      300           |
-	 * |      1200           |      1200          |
-	 * |      2400           |      2400          |
-	 * |      4800           |      4800          |
-	 * |      9600           |      9600          |
-	 * |      19200          |      19200         |
-	 * |      38400          |      38400         |
-	 * |      57600          |      57600         |
-	 * |      115200         |      115200        |
-	 * |      230400         |      230400        |
-	 * |      460800         |      460800        |
-	 * |      921600         |      921600        |
-	 * |      2000000        |      2000000       |
-	 * |      3000000        |      3000000       |
-	 * |      3200000        |      3200000       |
-	 * |      4000000        |      4000000       |
-	 * +---------------------+--------------------+
-	 */
-
-	return dev_pm_opp_set_level(perf_dev, baud);
-}
-
-static void qcom_geni_serial_set_termios(struct uart_port *uport,
-					 struct ktermios *termios,
-					 const struct ktermios *old)
-{
-	struct qcom_geni_serial_port *port = to_dev_port(uport);
-	unsigned int baud;
-	unsigned long timeout;
-	u32 bits_per_char;
-	u32 tx_trans_cfg;
-	u32 tx_parity_cfg;
-	u32 rx_trans_cfg;
-	u32 rx_parity_cfg;
-	u32 stop_bit_len;
-	int ret = 0;
-
-	/* baud rate */
-	baud = uart_get_baud_rate(uport, termios, old, 300, 8000000);
-
-	ret = port->dev_data->set_rate(uport, baud);
-	if (ret)
-		return;
-
 	/* parity */
 	tx_trans_cfg = readl(uport->membase + SE_UART_TX_TRANS_CFG);
 	tx_parity_cfg = readl(uport->membase + SE_UART_TX_PARITY_CFG);
@@ -1495,6 +1406,8 @@ static void qcom_geni_serial_set_termios(struct uart_port *uport,
 	writel(bits_per_char, uport->membase + SE_UART_TX_WORD_LEN);
 	writel(bits_per_char, uport->membase + SE_UART_RX_WORD_LEN);
 	writel(stop_bit_len, uport->membase + SE_UART_TX_STOP_BIT_LEN);
+	writel(ser_clk_cfg, uport->membase + GENI_SER_M_CLK_CFG);
+	writel(ser_clk_cfg, uport->membase + GENI_SER_S_CLK_CFG);
 }
 
 #ifdef CONFIG_SERIAL_QCOM_GENI_CONSOLE
@@ -1675,130 +1588,26 @@ static struct uart_driver qcom_geni_uart_driver = {
 	.nr =  GENI_UART_PORTS,
 };
 
-static int geni_serial_resources_on(struct uart_port *uport)
-{
-	struct qcom_geni_serial_port *port = to_dev_port(uport);
-	int ret;
-
-	ret = geni_icc_enable(&port->se);
-	if (ret)
-		return ret;
-
-	ret = geni_se_resources_on(&port->se);
-	if (ret) {
-		geni_icc_disable(&port->se);
-		return ret;
-	}
-
-	if (port->clk_rate)
-		dev_pm_opp_set_rate(uport->dev, port->clk_rate);
-
-	return 0;
-}
-
-static int geni_serial_resources_off(struct uart_port *uport)
-{
-	struct qcom_geni_serial_port *port = to_dev_port(uport);
-	int ret;
-
-	dev_pm_opp_set_rate(uport->dev, 0);
-	ret = geni_se_resources_off(&port->se);
-	if (ret)
-		return ret;
-
-	geni_icc_disable(&port->se);
-
-	return 0;
-}
-
-static int geni_serial_resource_state(struct uart_port *uport, bool power_on)
-{
-	return power_on ? geni_serial_resources_on(uport) : geni_serial_resources_off(uport);
-}
-
-static int geni_serial_pwr_init(struct uart_port *uport)
-{
-	struct qcom_geni_serial_port *port = to_dev_port(uport);
-	int ret;
-
-	ret = dev_pm_domain_attach_list(port->se.dev,
-					&port->dev_data->pd_data, &port->pd_list);
-	if (ret <= 0)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int geni_serial_resource_init(struct uart_port *uport)
-{
-	struct qcom_geni_serial_port *port = to_dev_port(uport);
-	int ret;
-
-	port->se.clk = devm_clk_get(port->se.dev, "se");
-	if (IS_ERR(port->se.clk)) {
-		ret = PTR_ERR(port->se.clk);
-		dev_err(port->se.dev, "Err getting SE Core clk %d\n", ret);
-		return ret;
-	}
-
-	ret = geni_icc_get(&port->se, NULL);
-	if (ret)
-		return ret;
-
-	port->se.icc_paths[GENI_TO_CORE].avg_bw = GENI_DEFAULT_BW;
-	port->se.icc_paths[CPU_TO_GENI].avg_bw = GENI_DEFAULT_BW;
-
-	/* Set BW for register access */
-	ret = geni_icc_set_bw(&port->se);
-	if (ret)
-		return ret;
-
-	ret = devm_pm_opp_set_clkname(port->se.dev, "se");
-	if (ret)
-		return ret;
-
-	/* OPP table is optional */
-	ret = devm_pm_opp_of_add_table(port->se.dev);
-	if (ret && ret != -ENODEV) {
-		dev_err(port->se.dev, "invalid OPP table in device tree\n");
-		return ret;
-	}
-
-	return 0;
-}
-
 static void qcom_geni_serial_pm(struct uart_port *uport,
 		unsigned int new_state, unsigned int old_state)
 {
+	struct qcom_geni_serial_port *port = to_dev_port(uport);
 
 	/* If we've never been called, treat it as off */
 	if (old_state == UART_PM_STATE_UNDEFINED)
 		old_state = UART_PM_STATE_OFF;
 
-	if (new_state == UART_PM_STATE_ON && old_state == UART_PM_STATE_OFF)
-		pm_runtime_resume_and_get(uport->dev);
-	else if (new_state == UART_PM_STATE_OFF &&
-		 old_state == UART_PM_STATE_ON)
-		pm_runtime_put_sync(uport->dev);
-
-}
-
-/**
- * qcom_geni_rs485_config - Configure RS485 settings for the UART port
- * @uport: Pointer to the UART port structure
- * @termios: Pointer to the termios structure
- * @rs485: Pointer to the RS485 configuration structure
- * This function configures the RTS (Request to Send) pin behavior for RS485 mode.
- * When RS485 mode is enabled, the RTS pin is kept in default ACTIVE HIGH state.
- * Return: Always returns 0.
- */
-
-static int qcom_geni_rs485_config(struct uart_port *uport,
-				  struct ktermios *termios, struct serial_rs485 *rs485)
-{
-	qcom_geni_set_rs485_mode(uport, SER_RS485_ENABLED);
-
-	return 0;
+	if (new_state == UART_PM_STATE_ON && old_state == UART_PM_STATE_OFF) {
+		geni_icc_enable(&port->se);
+		if (port->clk_rate)
+			dev_pm_opp_set_rate(uport->dev, port->clk_rate);
+		geni_se_resources_on(&port->se);
+	} else if (new_state == UART_PM_STATE_OFF &&
+			old_state == UART_PM_STATE_ON) {
+		geni_se_resources_off(&port->se);
+		dev_pm_opp_set_rate(uport->dev, 0);
+		geni_icc_disable(&port->se);
+	}
 }
 
 static const struct uart_ops qcom_geni_console_pops = {
@@ -1881,21 +1690,18 @@ static int qcom_geni_serial_probe(struct platform_device *pdev)
 	port->dev_data = data;
 	port->se.dev = &pdev->dev;
 	port->se.wrapper = dev_get_drvdata(pdev->dev.parent);
-
-	ret = port->dev_data->resources_init(uport);
-	if (ret)
+	port->se.clk = devm_clk_get(&pdev->dev, "se");
+	if (IS_ERR(port->se.clk)) {
+		ret = PTR_ERR(port->se.clk);
+		dev_err(&pdev->dev, "Err getting SE Core clk %d\n", ret);
 		return ret;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!res) {
-		ret = -EINVAL;
-		goto error;
 	}
 
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
 	uport->mapbase = res->start;
 
-	uport->rs485_config = qcom_geni_rs485_config;
-	uport->rs485_supported = qcom_geni_rs485_supported;
 	port->tx_fifo_depth = DEF_FIFO_DEPTH_WORDS;
 	port->rx_fifo_depth = DEF_FIFO_DEPTH_WORDS;
 	port->tx_fifo_width = DEF_FIFO_WIDTH_BITS;
@@ -1903,26 +1709,30 @@ static int qcom_geni_serial_probe(struct platform_device *pdev)
 	if (!data->console) {
 		port->rx_buf = devm_kzalloc(uport->dev,
 					    DMA_RX_BUF_SIZE, GFP_KERNEL);
-		if (!port->rx_buf) {
-			ret = -ENOMEM;
-			goto error;
-		}
+		if (!port->rx_buf)
+			return -ENOMEM;
 	}
 
+	ret = geni_icc_get(&port->se, NULL);
+	if (ret)
+		return ret;
+	port->se.icc_paths[GENI_TO_CORE].avg_bw = GENI_DEFAULT_BW;
+	port->se.icc_paths[CPU_TO_GENI].avg_bw = GENI_DEFAULT_BW;
+
+	/* Set BW for register access */
+	ret = geni_icc_set_bw(&port->se);
+	if (ret)
+		return ret;
+
 	port->name = devm_kasprintf(uport->dev, GFP_KERNEL,
 			"qcom_geni_serial_%s%d",
 			uart_console(uport) ? "console" : "uart", uport->line);
-	if (!port->name) {
-		ret = -ENOMEM;
-		goto error;
-	}
+	if (!port->name)
+		return -ENOMEM;
 
 	irq = platform_get_irq(pdev, 0);
-	if (irq < 0) {
-		ret = irq;
-		goto error;
-	}
-
+	if (irq < 0)
+		return irq;
 	uport->irq = irq;
 	uport->has_sysrq = IS_ENABLED(CONFIG_SERIAL_QCOM_GENI_CONSOLE);
 
@@ -1935,6 +1745,16 @@ static int qcom_geni_serial_probe(struct platform_device *pdev)
 	if (of_property_read_bool(pdev->dev.of_node, "cts-rts-swap"))
 		port->cts_rts_swap = true;
 
+	ret = devm_pm_opp_set_clkname(&pdev->dev, "se");
+	if (ret)
+		return ret;
+	/* OPP table is optional */
+	ret = devm_pm_opp_of_add_table(&pdev->dev);
+	if (ret && ret != -ENODEV) {
+		dev_err(&pdev->dev, "invalid OPP table in device tree\n");
+		return ret;
+	}
+
 	port->private_data.drv = drv;
 	uport->private_data = &port->private_data;
 	platform_set_drvdata(pdev, port);
@@ -1944,18 +1764,12 @@ static int qcom_geni_serial_probe(struct platform_device *pdev)
 			IRQF_TRIGGER_HIGH, port->name, uport);
 	if (ret) {
 		dev_err(uport->dev, "Failed to get IRQ ret %d\n", ret);
-		goto error;
-	}
-
-	ret = uart_get_rs485_mode(uport);
-	if (ret)
 		return ret;
-
-	devm_pm_runtime_enable(port->se.dev);
+	}
 
 	ret = uart_add_one_port(drv, uport);
 	if (ret)
-		goto error;
+		return ret;
 
 	if (port->wakeup_irq > 0) {
 		device_init_wakeup(&pdev->dev, true);
@@ -1965,15 +1779,11 @@ static int qcom_geni_serial_probe(struct platform_device *pdev)
 			device_init_wakeup(&pdev->dev, false);
 			ida_free(&port_ida, uport->line);
 			uart_remove_one_port(drv, uport);
-			goto error;
+			return ret;
 		}
 	}
 
 	return 0;
-
-error:
-	dev_pm_domain_detach_list(port->pd_list);
-	return ret;
 }
 
 static void qcom_geni_serial_remove(struct platform_device *pdev)
@@ -1986,31 +1796,6 @@ static void qcom_geni_serial_remove(struct platform_device *pdev)
 	device_init_wakeup(&pdev->dev, false);
 	ida_free(&port_ida, uport->line);
 	uart_remove_one_port(drv, &port->uport);
-	dev_pm_domain_detach_list(port->pd_list);
-}
-
-static int __maybe_unused qcom_geni_serial_runtime_suspend(struct device *dev)
-{
-	struct qcom_geni_serial_port *port = dev_get_drvdata(dev);
-	struct uart_port *uport = &port->uport;
-	int ret = 0;
-
-	if (port->dev_data->power_state)
-		ret = port->dev_data->power_state(uport, false);
-
-	return ret;
-}
-
-static int __maybe_unused qcom_geni_serial_runtime_resume(struct device *dev)
-{
-	struct qcom_geni_serial_port *port = dev_get_drvdata(dev);
-	struct uart_port *uport = &port->uport;
-	int ret = 0;
-
-	if (port->dev_data->power_state)
-		ret = port->dev_data->power_state(uport, true);
-
-	return ret;
 }
 
 static int qcom_geni_serial_suspend(struct device *dev)
@@ -2048,46 +1833,14 @@ static int qcom_geni_serial_resume(struct device *dev)
 static const struct qcom_geni_device_data qcom_geni_console_data = {
 	.console = true,
 	.mode = GENI_SE_FIFO,
-	.resources_init = geni_serial_resource_init,
-	.set_rate = geni_serial_set_rate,
-	.power_state = geni_serial_resource_state,
 };
 
 static const struct qcom_geni_device_data qcom_geni_uart_data = {
 	.console = false,
 	.mode = GENI_SE_DMA,
-	.resources_init = geni_serial_resource_init,
-	.set_rate = geni_serial_set_rate,
-	.power_state = geni_serial_resource_state,
-};
-
-static const struct qcom_geni_device_data sa8255p_qcom_geni_console_data = {
-	.console = true,
-	.mode = GENI_SE_FIFO,
-	.pd_data = {
-		.pd_flags = PD_FLAG_DEV_LINK_ON,
-		.pd_names = (const char*[]) { "power", "perf" },
-		.num_pd_names = 2,
-	},
-	.resources_init = geni_serial_pwr_init,
-	.set_rate = geni_serial_set_level,
-};
-
-static const struct qcom_geni_device_data sa8255p_qcom_geni_uart_data = {
-	.console = false,
-	.mode = GENI_SE_DMA,
-	.pd_data = {
-		.pd_flags = PD_FLAG_DEV_LINK_ON,
-		.pd_names = (const char*[]) { "power", "perf" },
-		.num_pd_names = 2,
-	},
-	.resources_init = geni_serial_pwr_init,
-	.set_rate = geni_serial_set_level,
 };
 
 static const struct dev_pm_ops qcom_geni_serial_pm_ops = {
-	SET_RUNTIME_PM_OPS(qcom_geni_serial_runtime_suspend,
-			   qcom_geni_serial_runtime_resume, NULL)
 	SYSTEM_SLEEP_PM_OPS(qcom_geni_serial_suspend, qcom_geni_serial_resume)
 };
 
@@ -2096,18 +1849,10 @@ static const struct of_device_id qcom_geni_serial_match_table[] = {
 		.compatible = "qcom,geni-debug-uart",
 		.data = &qcom_geni_console_data,
 	},
-	{
-		.compatible = "qcom,sa8255p-geni-debug-uart",
-		.data = &sa8255p_qcom_geni_console_data,
-	},
 	{
 		.compatible = "qcom,geni-uart",
 		.data = &qcom_geni_uart_data,
 	},
-	{
-		.compatible = "qcom,sa8255p-geni-uart",
-		.data = &sa8255p_qcom_geni_uart_data,
-	},
 	{}
 };
 MODULE_DEVICE_TABLE(of, qcom_geni_serial_match_table);
diff --git a/drivers/tty/serial/rsci.c b/drivers/tty/serial/rsci.c
deleted file mode 100644
index b3c48dc1e07db..0000000000000
--- a/drivers/tty/serial/rsci.c
+++ /dev/null
@@ -1,480 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Copyright (C) 2025 Renesas Electronics Corp.
- */
-
-#include <linux/bitfield.h>
-#include <linux/bitops.h>
-#include <linux/io.h>
-#include <linux/iopoll.h>
-#include <linux/module.h>
-#include <linux/serial_core.h>
-#include <linux/serial_sci.h>
-#include <linux/tty_flip.h>
-#include "rsci.h"
-
-MODULE_IMPORT_NS("SH_SCI");
-
-/* RSCI registers */
-#define RDR	0x00
-#define TDR	0x04
-#define CCR0	0x08
-#define CCR1	0x0C
-#define CCR2	0x10
-#define CCR3	0x14
-#define CCR4	0x18
-#define FCR	0x24
-#define DCR	0x30
-#define CSR	0x48
-#define FRSR	0x50
-#define FTSR	0x54
-#define CFCLR	0x68
-#define FFCLR	0x70
-
-/* RDR (Receive Data Register) */
-#define RDR_FFER		BIT(12) /* FIFO Framing Error */
-#define RDR_FPER		BIT(11) /* FIFO Parity Error */
-#define RDR_RDAT_MSK		GENMASK(8, 0)
-
-/* TDR (Transmit Data Register) */
-#define TDR_MPBT		BIT(9)	/* Multiprocessor Transfer */
-#define TDR_TDAT_9BIT_LSHIFT	0
-#define TDR_TDAT_9BIT_VAL	0x1FF
-#define TDR_TDAT_9BIT_MSK	(TDR_TDAT_9BIT_VAL << TDR_TDAT_9BIT_LSHIFT)
-
-/* CCR0 (Common Control Register 0) */
-#define CCR0_SSE		BIT(24)	/* SSn# Pin Function Enable */
-#define CCR0_TEIE		BIT(21)	/* Transmit End Interrupt Enable */
-#define CCR0_TIE		BIT(20)	/* Transmit Interrupt Enable */
-#define CCR0_RIE		BIT(16)	/* Receive Interrupt Enable */
-#define CCR0_IDSEL		BIT(10)	/* ID Frame Select */
-#define CCR0_DCME		BIT(9)	/* Data Compare Match Enable */
-#define CCR0_MPIE		BIT(8)	/* Multiprocessor Interrupt Enable */
-#define CCR0_TE			BIT(4)	/* Transmit Enable */
-#define CCR0_RE			BIT(0)	/* Receive Enable */
-
-/* CCR1 (Common Control Register 1) */
-#define CCR1_NFEN		BIT(28)	/* Digital Noise Filter Function */
-#define CCR1_SHARPS		BIT(20)	/* Half -duplex Communication Select */
-#define CCR1_SPLP		BIT(16)	/* Loopback Control */
-#define CCR1_RINV		BIT(13)	/* RxD invert */
-#define CCR1_TINV		BIT(12)	/* TxD invert */
-#define CCR1_PM			BIT(9)	/* Parity Mode */
-#define CCR1_PE			BIT(8)	/* Parity Enable */
-#define CCR1_SPB2IO		BIT(5)	/* Serial Port Break I/O */
-#define CCR1_SPB2DT		BIT(4)	/* Serial Port Break Data Select */
-#define CCR1_CTSPEN		BIT(1)	/* CTS External Pin Enable */
-#define CCR1_CTSE		BIT(0)	/* CTS Enable */
-
-/* FCR (FIFO Control Register) */
-#define FCR_RFRST		BIT(23)	/* Receive FIFO Data Register Reset */
-#define FCR_TFRST		BIT(15)	/* Transmit FIFO Data Register Reset */
-#define FCR_DRES		BIT(0)	/* Incoming Data Ready Error Select */
-#define FCR_RTRG4_0		GENMASK(20, 16)
-#define FCR_TTRG		GENMASK(12, 8)
-
-/* CSR (Common Status Register) */
-#define CSR_RDRF		BIT(31)	/* Receive Data Full */
-#define CSR_TEND		BIT(30)	/* Transmit End Flag */
-#define CSR_TDRE		BIT(29)	/* Transmit Data Empty */
-#define CSR_FER			BIT(28)	/* Framing Error */
-#define CSR_PER			BIT(27)	/* Parity Error */
-#define CSR_MFF			BIT(26)	/* Mode Fault Error */
-#define CSR_ORER		BIT(24)	/* Overrun Error */
-#define CSR_DFER		BIT(18)	/* Data Compare Match Framing Error */
-#define CSR_DPER		BIT(17)	/* Data Compare Match Parity Error */
-#define CSR_DCMF		BIT(16)	/* Data Compare Match */
-#define CSR_RXDMON		BIT(15)	/* Serial Input Data Monitor */
-#define CSR_ERS			BIT(4)	/* Error Signal Status */
-
-#define SCxSR_ERRORS(port)	(to_sci_port(port)->params->error_mask)
-#define SCxSR_ERROR_CLEAR(port)	(to_sci_port(port)->params->error_clear)
-
-#define RSCI_DEFAULT_ERROR_MASK	(CSR_PER | CSR_FER)
-
-#define RSCI_RDxF_CLEAR		(CFCLR_RDRFC)
-#define RSCI_ERROR_CLEAR	(CFCLR_PERC | CFCLR_FERC)
-#define RSCI_TDxE_CLEAR		(CFCLR_TDREC)
-#define RSCI_BREAK_CLEAR	(CFCLR_PERC | CFCLR_FERC | CFCLR_ORERC)
-
-/* FRSR (FIFO Receive Status Register) */
-#define FRSR_R5_0		GENMASK(13, 8)	/* Receive FIFO Data Count */
-#define FRSR_DR			BIT(0)	/* Receive Data Ready */
-
-/* CFCLR (Common Flag CLear Register) */
-#define CFCLR_RDRFC		BIT(31)	/* RDRF Clear */
-#define CFCLR_TDREC		BIT(29)	/* TDRE Clear */
-#define CFCLR_FERC		BIT(28)	/* FER Clear */
-#define CFCLR_PERC		BIT(27)	/* PER Clear */
-#define CFCLR_MFFC		BIT(26)	/* MFF Clear */
-#define CFCLR_ORERC		BIT(24)	/* ORER Clear */
-#define CFCLR_DFERC		BIT(18)	/* DFER Clear */
-#define CFCLR_DPERC		BIT(17)	/* DPER Clear */
-#define CFCLR_DCMFC		BIT(16)	/* DCMF Clear */
-#define CFCLR_ERSC		BIT(4)	/* ERS Clear */
-#define CFCLR_CLRFLAG		(CFCLR_RDRFC | CFCLR_FERC | CFCLR_PERC | \
-				 CFCLR_MFFC | CFCLR_ORERC | CFCLR_DFERC | \
-				 CFCLR_DPERC | CFCLR_DCMFC | CFCLR_ERSC)
-
-/* FFCLR (FIFO Flag CLear Register) */
-#define FFCLR_DRC		BIT(0)	/* DR Clear */
-
-#define DCR_DEPOL		BIT(0)
-
-static u32 rsci_serial_in(struct uart_port *p, int offset)
-{
-	return readl(p->membase + offset);
-}
-
-static void rsci_serial_out(struct uart_port *p, int offset, int value)
-{
-	writel(value, p->membase + offset);
-}
-
-static void rsci_clear_DRxC(struct uart_port *port)
-{
-	rsci_serial_out(port, CFCLR, CFCLR_RDRFC);
-	rsci_serial_out(port, FFCLR, FFCLR_DRC);
-}
-
-static void rsci_clear_SCxSR(struct uart_port *port, unsigned int mask)
-{
-	rsci_serial_out(port, CFCLR, mask);
-}
-
-static void rsci_start_rx(struct uart_port *port)
-{
-	unsigned int ctrl;
-
-	ctrl = rsci_serial_in(port, CCR0);
-	ctrl |= CCR0_RIE;
-	rsci_serial_out(port, CCR0, ctrl);
-}
-
-static void rsci_set_termios(struct uart_port *port, struct ktermios *termios,
-			     const struct ktermios *old)
-{
-	struct sci_port *s = to_sci_port(port);
-	unsigned long flags;
-
-	sci_port_enable(s);
-	uart_port_lock_irqsave(port, &flags);
-
-	/* For now, only RX enabling is supported */
-	if (termios->c_cflag & CREAD)
-		rsci_start_rx(port);
-
-	uart_port_unlock_irqrestore(port, flags);
-	sci_port_disable(s);
-}
-
-static int rsci_txfill(struct uart_port *port)
-{
-	return rsci_serial_in(port, FTSR);
-}
-
-static int rsci_rxfill(struct uart_port *port)
-{
-	u32 val = rsci_serial_in(port, FRSR);
-
-	return FIELD_GET(FRSR_R5_0, val);
-}
-
-static unsigned int rsci_tx_empty(struct uart_port *port)
-{
-	unsigned int status = rsci_serial_in(port, CSR);
-	unsigned int in_tx_fifo = rsci_txfill(port);
-
-	return (status & CSR_TEND) && !in_tx_fifo ? TIOCSER_TEMT : 0;
-}
-
-static void rsci_set_mctrl(struct uart_port *port, unsigned int mctrl)
-{
-	/* Not supported yet */
-}
-
-static unsigned int rsci_get_mctrl(struct uart_port *port)
-{
-	/* Not supported yet */
-	return 0;
-}
-
-static void rsci_clear_CFC(struct uart_port *port, unsigned int mask)
-{
-	rsci_serial_out(port, CFCLR, mask);
-}
-
-static void rsci_start_tx(struct uart_port *port)
-{
-	struct sci_port *sp = to_sci_port(port);
-	u32 ctrl;
-
-	if (sp->chan_tx)
-		return;
-
-	/*
-	 * TE (Transmit Enable) must be set after setting TIE
-	 * (Transmit Interrupt Enable) or in the same instruction
-	 * to start the transmit process.
-	 */
-	ctrl = rsci_serial_in(port, CCR0);
-	ctrl |= CCR0_TIE | CCR0_TE;
-	rsci_serial_out(port, CCR0, ctrl);
-}
-
-static void rsci_stop_tx(struct uart_port *port)
-{
-	u32 ctrl;
-
-	ctrl = rsci_serial_in(port, CCR0);
-	ctrl &= ~CCR0_TIE;
-	rsci_serial_out(port, CCR0, ctrl);
-}
-
-static void rsci_stop_rx(struct uart_port *port)
-{
-	u32 ctrl;
-
-	ctrl = rsci_serial_in(port, CCR0);
-	ctrl &= ~CCR0_RIE;
-	rsci_serial_out(port, CCR0, ctrl);
-}
-
-static int rsci_txroom(struct uart_port *port)
-{
-	return port->fifosize - rsci_txfill(port);
-}
-
-static void rsci_transmit_chars(struct uart_port *port)
-{
-	unsigned int stopped = uart_tx_stopped(port);
-	struct tty_port *tport = &port->state->port;
-	u32 status, ctrl;
-	int count;
-
-	status = rsci_serial_in(port, CSR);
-	if (!(status & CSR_TDRE)) {
-		ctrl = rsci_serial_in(port, CCR0);
-		if (kfifo_is_empty(&tport->xmit_fifo))
-			ctrl &= ~CCR0_TIE;
-		else
-			ctrl |= CCR0_TIE;
-		rsci_serial_out(port, CCR0, ctrl);
-		return;
-	}
-
-	count = rsci_txroom(port);
-
-	do {
-		unsigned char c;
-
-		if (port->x_char) {
-			c = port->x_char;
-			port->x_char = 0;
-		} else if (stopped || !kfifo_get(&tport->xmit_fifo, &c)) {
-			break;
-		}
-
-		rsci_clear_CFC(port, CFCLR_TDREC);
-		rsci_serial_out(port, TDR, c);
-
-		port->icount.tx++;
-	} while (--count > 0);
-
-	if (kfifo_len(&tport->xmit_fifo) < WAKEUP_CHARS)
-		uart_write_wakeup(port);
-
-	if (kfifo_is_empty(&tport->xmit_fifo)) {
-		ctrl = rsci_serial_in(port, CCR0);
-		ctrl &= ~CCR0_TIE;
-		ctrl |= CCR0_TEIE;
-		rsci_serial_out(port, CCR0, ctrl);
-	}
-}
-
-static void rsci_receive_chars(struct uart_port *port)
-{
-	struct tty_port *tport = &port->state->port;
-	u32 rdat, status, frsr_status = 0;
-	int i, count, copied = 0;
-	unsigned char flag;
-
-	status = rsci_serial_in(port, CSR);
-	frsr_status = rsci_serial_in(port, FRSR);
-
-	if (!(status & CSR_RDRF) && !(frsr_status & FRSR_DR))
-		return;
-
-	while (1) {
-		/* Don't copy more bytes than there is room for in the buffer */
-		count = tty_buffer_request_room(tport, rsci_rxfill(port));
-
-		/* If for any reason we can't copy more data, we're done! */
-		if (count == 0)
-			break;
-
-		for (i = 0; i < count; i++) {
-			char c;
-
-			rdat = rsci_serial_in(port, RDR);
-			/* 9-bits data is not supported yet */
-			c = rdat & RDR_RDAT_MSK;
-
-			if (uart_handle_sysrq_char(port, c)) {
-				count--;
-				i--;
-				continue;
-			}
-
-			/* Store data and status.
-			 * Non FIFO mode is not supported
-			 */
-			if (rdat & RDR_FFER) {
-				flag = TTY_FRAME;
-				port->icount.frame++;
-			} else if (rdat & RDR_FPER) {
-				flag = TTY_PARITY;
-				port->icount.parity++;
-			} else {
-				flag = TTY_NORMAL;
-			}
-
-			tty_insert_flip_char(tport, c, flag);
-		}
-
-		rsci_serial_in(port, CSR); /* dummy read */
-		rsci_clear_DRxC(port);
-
-		copied += count;
-		port->icount.rx += count;
-	}
-
-	if (copied) {
-		/* Tell the rest of the system the news. New characters! */
-		tty_flip_buffer_push(tport);
-	} else {
-		/* TTY buffers full; read from RX reg to prevent lockup */
-		rsci_serial_in(port, RDR);
-		rsci_serial_in(port, CSR); /* dummy read */
-		rsci_clear_DRxC(port);
-	}
-}
-
-static void rsci_poll_put_char(struct uart_port *port, unsigned char c)
-{
-	u32 status;
-	int ret;
-
-	ret = readl_relaxed_poll_timeout_atomic(port->membase + CSR, status,
-						(status & CSR_TDRE), 100,
-						USEC_PER_SEC);
-	if (ret != 0) {
-		dev_err(port->dev,
-			"Error while sending data in UART TX : %d\n", ret);
-		goto done;
-	}
-	rsci_serial_out(port, TDR, c);
-done:
-	rsci_clear_SCxSR(port, CFCLR_TDREC);
-}
-
-static void rsci_prepare_console_write(struct uart_port *port, u32 ctrl)
-{
-	struct sci_port *s = to_sci_port(port);
-	u32 ctrl_temp =
-		s->params->param_bits->rxtx_enable | CCR0_TIE |
-		s->hscif_tot;
-	rsci_serial_out(port, CCR0, ctrl_temp);
-}
-
-static const char *rsci_type(struct uart_port *port)
-{
-	return "rsci";
-}
-
-static size_t rsci_suspend_regs_size(void)
-{
-	return 0;
-}
-
-static void rsci_shutdown_complete(struct uart_port *port)
-{
-	/*
-	 * Stop RX and TX, disable related interrupts, keep clock source
-	 */
-	rsci_serial_out(port, CCR0, 0);
-}
-
-static const struct sci_common_regs rsci_common_regs = {
-	.status = CSR,
-	.control = CCR0,
-};
-
-static const struct sci_port_params_bits rsci_port_param_bits = {
-	.rxtx_enable = CCR0_RE | CCR0_TE,
-	.te_clear = CCR0_TE | CCR0_TEIE,
-	.poll_sent_bits = CSR_TDRE | CSR_TEND,
-};
-
-static const struct sci_port_params rsci_port_params = {
-	.fifosize = 16,
-	.overrun_reg = CSR,
-	.overrun_mask = CSR_ORER,
-	.sampling_rate_mask = SCI_SR(32),
-	.error_mask = RSCI_DEFAULT_ERROR_MASK,
-	.error_clear = RSCI_ERROR_CLEAR,
-	.param_bits = &rsci_port_param_bits,
-	.common_regs = &rsci_common_regs,
-};
-
-static const struct uart_ops rsci_uart_ops = {
-	.tx_empty	= rsci_tx_empty,
-	.set_mctrl	= rsci_set_mctrl,
-	.get_mctrl	= rsci_get_mctrl,
-	.start_tx	= rsci_start_tx,
-	.stop_tx	= rsci_stop_tx,
-	.stop_rx	= rsci_stop_rx,
-	.startup	= sci_startup,
-	.shutdown	= sci_shutdown,
-	.set_termios	= rsci_set_termios,
-	.pm		= sci_pm,
-	.type		= rsci_type,
-	.release_port	= sci_release_port,
-	.request_port	= sci_request_port,
-	.config_port	= sci_config_port,
-	.verify_port	= sci_verify_port,
-};
-
-static const struct sci_port_ops rsci_port_ops = {
-	.read_reg		= rsci_serial_in,
-	.write_reg		= rsci_serial_out,
-	.clear_SCxSR		= rsci_clear_SCxSR,
-	.transmit_chars		= rsci_transmit_chars,
-	.receive_chars		= rsci_receive_chars,
-	.poll_put_char		= rsci_poll_put_char,
-	.prepare_console_write	= rsci_prepare_console_write,
-	.suspend_regs_size	= rsci_suspend_regs_size,
-	.shutdown_complete	= rsci_shutdown_complete,
-};
-
-struct sci_of_data of_sci_rsci_data = {
-	.type = SCI_PORT_RSCI,
-	.ops = &rsci_port_ops,
-	.uart_ops = &rsci_uart_ops,
-	.params = &rsci_port_params,
-};
-
-#ifdef CONFIG_SERIAL_SH_SCI_EARLYCON
-
-static int __init rsci_early_console_setup(struct earlycon_device *device,
-					   const char *opt)
-{
-	return scix_early_console_setup(device, &of_sci_rsci_data);
-}
-
-OF_EARLYCON_DECLARE(rsci, "renesas,r9a09g077-rsci", rsci_early_console_setup);
-
-#endif /* CONFIG_SERIAL_SH_SCI_EARLYCON */
-
-MODULE_LICENSE("GPL");
-MODULE_DESCRIPTION("RSCI serial driver");
diff --git a/drivers/tty/serial/rsci.h b/drivers/tty/serial/rsci.h
deleted file mode 100644
index 2af3f28b465a2..0000000000000
--- a/drivers/tty/serial/rsci.h
+++ /dev/null
@@ -1,10 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-
-#ifndef __RSCI_H__
-#define __RSCI_H__
-
-#include "sh-sci-common.h"
-
-extern struct sci_of_data of_sci_rsci_data;
-
-#endif /* __RSCI_H__ */
diff --git a/drivers/tty/serial/serial_core.c b/drivers/tty/serial/serial_core.c
index 86d404d649a35..1f7708a91fc6d 100644
--- a/drivers/tty/serial/serial_core.c
+++ b/drivers/tty/serial/serial_core.c
@@ -1337,28 +1337,28 @@ static void uart_sanitize_serial_rs485_delays(struct uart_port *port,
 	if (!port->rs485_supported.delay_rts_before_send) {
 		if (rs485->delay_rts_before_send) {
 			dev_warn_ratelimited(port->dev,
-				"%s (%u): RTS delay before sending not supported\n",
+				"%s (%d): RTS delay before sending not supported\n",
 				port->name, port->line);
 		}
 		rs485->delay_rts_before_send = 0;
 	} else if (rs485->delay_rts_before_send > RS485_MAX_RTS_DELAY) {
 		rs485->delay_rts_before_send = RS485_MAX_RTS_DELAY;
 		dev_warn_ratelimited(port->dev,
-			"%s (%u): RTS delay before sending clamped to %u ms\n",
+			"%s (%d): RTS delay before sending clamped to %u ms\n",
 			port->name, port->line, rs485->delay_rts_before_send);
 	}
 
 	if (!port->rs485_supported.delay_rts_after_send) {
 		if (rs485->delay_rts_after_send) {
 			dev_warn_ratelimited(port->dev,
-				"%s (%u): RTS delay after sending not supported\n",
+				"%s (%d): RTS delay after sending not supported\n",
 				port->name, port->line);
 		}
 		rs485->delay_rts_after_send = 0;
 	} else if (rs485->delay_rts_after_send > RS485_MAX_RTS_DELAY) {
 		rs485->delay_rts_after_send = RS485_MAX_RTS_DELAY;
 		dev_warn_ratelimited(port->dev,
-			"%s (%u): RTS delay after sending clamped to %u ms\n",
+			"%s (%d): RTS delay after sending clamped to %u ms\n",
 			port->name, port->line, rs485->delay_rts_after_send);
 	}
 }
@@ -1388,14 +1388,14 @@ static void uart_sanitize_serial_rs485(struct uart_port *port, struct serial_rs4
 			rs485->flags &= ~SER_RS485_RTS_AFTER_SEND;
 
 			dev_warn_ratelimited(port->dev,
-				"%s (%u): invalid RTS setting, using RTS_ON_SEND instead\n",
+				"%s (%d): invalid RTS setting, using RTS_ON_SEND instead\n",
 				port->name, port->line);
 		} else {
 			rs485->flags |= SER_RS485_RTS_AFTER_SEND;
 			rs485->flags &= ~SER_RS485_RTS_ON_SEND;
 
 			dev_warn_ratelimited(port->dev,
-				"%s (%u): invalid RTS setting, using RTS_AFTER_SEND instead\n",
+				"%s (%d): invalid RTS setting, using RTS_AFTER_SEND instead\n",
 				port->name, port->line);
 		}
 	}
@@ -1834,7 +1834,7 @@ static void uart_wait_until_sent(struct tty_struct *tty, int timeout)
 
 	expire = jiffies + timeout;
 
-	pr_debug("uart_wait_until_sent(%u), jiffies=%lu, expire=%lu...\n",
+	pr_debug("uart_wait_until_sent(%d), jiffies=%lu, expire=%lu...\n",
 		port->line, jiffies, expire);
 
 	/*
@@ -2028,7 +2028,7 @@ static void uart_line_info(struct seq_file *m, struct uart_state *state)
 		return;
 
 	mmio = uport->iotype >= UPIO_MEM;
-	seq_printf(m, "%u: uart:%s %s%08llX irq:%u",
+	seq_printf(m, "%d: uart:%s %s%08llX irq:%d",
 			uport->line, uart_type(uport),
 			mmio ? "mmio:0x" : "port:",
 			mmio ? (unsigned long long)uport->mapbase
@@ -2050,18 +2050,18 @@ static void uart_line_info(struct seq_file *m, struct uart_state *state)
 		if (pm_state != UART_PM_STATE_ON)
 			uart_change_pm(state, pm_state);
 
-		seq_printf(m, " tx:%u rx:%u",
+		seq_printf(m, " tx:%d rx:%d",
 				uport->icount.tx, uport->icount.rx);
 		if (uport->icount.frame)
-			seq_printf(m, " fe:%u",	uport->icount.frame);
+			seq_printf(m, " fe:%d",	uport->icount.frame);
 		if (uport->icount.parity)
-			seq_printf(m, " pe:%u",	uport->icount.parity);
+			seq_printf(m, " pe:%d",	uport->icount.parity);
 		if (uport->icount.brk)
-			seq_printf(m, " brk:%u", uport->icount.brk);
+			seq_printf(m, " brk:%d", uport->icount.brk);
 		if (uport->icount.overrun)
-			seq_printf(m, " oe:%u", uport->icount.overrun);
+			seq_printf(m, " oe:%d", uport->icount.overrun);
 		if (uport->icount.buf_overrun)
-			seq_printf(m, " bo:%u", uport->icount.buf_overrun);
+			seq_printf(m, " bo:%d", uport->icount.buf_overrun);
 
 #define INFOBIT(bit, str) \
 	if (uport->mctrl & (bit)) \
@@ -2131,6 +2131,33 @@ void uart_console_write(struct uart_port *port, const char *s,
 }
 EXPORT_SYMBOL_GPL(uart_console_write);
 
+/**
+ * uart_get_console - get uart port for console
+ * @ports: ports to search in
+ * @nr: number of @ports
+ * @co: console to search for
+ * Returns: uart_port for the console @co
+ *
+ * Check whether an invalid uart number has been specified (as @co->index), and
+ * if so, search for the first available port that does have console support.
+ */
+struct uart_port * __init
+uart_get_console(struct uart_port *ports, int nr, struct console *co)
+{
+	int idx = co->index;
+
+	if (idx < 0 || idx >= nr || (ports[idx].iobase == 0 &&
+				     ports[idx].membase == NULL))
+		for (idx = 0; idx < nr; idx++)
+			if (ports[idx].iobase != 0 ||
+			    ports[idx].membase != NULL)
+				break;
+
+	co->index = idx;
+
+	return ports + idx;
+}
+
 /**
  * uart_parse_earlycon - Parse earlycon options
  * @p:	     ptr to 2nd field (ie., just beyond '<name>,')
@@ -2526,7 +2553,7 @@ uart_report_port(struct uart_driver *drv, struct uart_port *port)
 		break;
 	}
 
-	pr_info("%s%s%s at %s (irq = %u, base_baud = %u) is a %s\n",
+	pr_info("%s%s%s at %s (irq = %d, base_baud = %d) is a %s\n",
 	       port->dev ? dev_name(port->dev) : "",
 	       port->dev ? ": " : "",
 	       port->name,
@@ -2534,7 +2561,7 @@ uart_report_port(struct uart_driver *drv, struct uart_port *port)
 
 	/* The magic multiplier feature is a bit obscure, so report it too.  */
 	if (port->flags & UPF_MAGIC_MULTIPLIER)
-		pr_info("%s%s%s extra baud rates supported: %u, %u",
+		pr_info("%s%s%s extra baud rates supported: %d, %d",
 			port->dev ? dev_name(port->dev) : "",
 			port->dev ? ": " : "",
 			port->name,
@@ -2933,7 +2960,7 @@ static ssize_t close_delay_show(struct device *dev,
 	struct tty_port *port = dev_get_drvdata(dev);
 
 	uart_get_info(port, &tmp);
-	return sprintf(buf, "%u\n", tmp.close_delay);
+	return sprintf(buf, "%d\n", tmp.close_delay);
 }
 
 static ssize_t closing_wait_show(struct device *dev,
@@ -2943,7 +2970,7 @@ static ssize_t closing_wait_show(struct device *dev,
 	struct tty_port *port = dev_get_drvdata(dev);
 
 	uart_get_info(port, &tmp);
-	return sprintf(buf, "%u\n", tmp.closing_wait);
+	return sprintf(buf, "%d\n", tmp.closing_wait);
 }
 
 static ssize_t custom_divisor_show(struct device *dev,
@@ -2963,7 +2990,7 @@ static ssize_t io_type_show(struct device *dev,
 	struct tty_port *port = dev_get_drvdata(dev);
 
 	uart_get_info(port, &tmp);
-	return sprintf(buf, "%u\n", tmp.io_type);
+	return sprintf(buf, "%d\n", tmp.io_type);
 }
 
 static ssize_t iomem_base_show(struct device *dev,
@@ -2983,7 +3010,7 @@ static ssize_t iomem_reg_shift_show(struct device *dev,
 	struct tty_port *port = dev_get_drvdata(dev);
 
 	uart_get_info(port, &tmp);
-	return sprintf(buf, "%u\n", tmp.iomem_reg_shift);
+	return sprintf(buf, "%d\n", tmp.iomem_reg_shift);
 }
 
 static ssize_t console_show(struct device *dev,
@@ -3119,7 +3146,7 @@ static int serial_core_add_one_port(struct uart_driver *drv, struct uart_port *u
 	state->pm_state = UART_PM_STATE_UNDEFINED;
 	uart_port_set_cons(uport, drv->cons);
 	uport->minor = drv->tty_driver->minor_start + uport->line;
-	uport->name = kasprintf(GFP_KERNEL, "%s%u", drv->dev_name,
+	uport->name = kasprintf(GFP_KERNEL, "%s%d", drv->dev_name,
 				drv->tty_driver->name_base + uport->line);
 	if (!uport->name)
 		return -ENOMEM;
@@ -3158,7 +3185,7 @@ static int serial_core_add_one_port(struct uart_driver *drv, struct uart_port *u
 		device_set_wakeup_capable(tty_dev, 1);
 	} else {
 		uport->flags |= UPF_DEAD;
-		dev_err(uport->dev, "Cannot register tty device on line %u\n",
+		dev_err(uport->dev, "Cannot register tty device on line %d\n",
 		       uport->line);
 	}
 
@@ -3182,6 +3209,7 @@ static void serial_core_remove_one_port(struct uart_driver *drv,
 	struct uart_state *state = drv->state + uport->line;
 	struct tty_port *port = &state->port;
 	struct uart_port *uart_port;
+	struct tty_struct *tty;
 
 	mutex_lock(&port->mutex);
 	uart_port = uart_port_check(state);
@@ -3200,7 +3228,11 @@ static void serial_core_remove_one_port(struct uart_driver *drv,
 	 */
 	tty_port_unregister_device(port, drv->tty_driver, uport->line);
 
-	tty_port_tty_vhangup(port);
+	tty = tty_port_tty_get(port);
+	if (tty) {
+		tty_vhangup(port->tty);
+		tty_kref_put(tty);
+	}
 
 	/*
 	 * If the port is used as a console, unregister it
diff --git a/drivers/tty/serial/sh-sci-common.h b/drivers/tty/serial/sh-sci-common.h
index e3c028df14f1a..bd9d9cfac1c83 100644
--- a/drivers/tty/serial/sh-sci-common.h
+++ b/drivers/tty/serial/sh-sci-common.h
@@ -5,11 +5,6 @@
 
 #include <linux/serial_core.h>
 
-/* Private port IDs */
-enum SCI_PORT_TYPE {
-	SCI_PORT_RSCI = BIT(7) | 0,
-};
-
 enum SCI_CLKS {
 	SCI_FCK,		/* Functional Clock */
 	SCI_SCK,		/* Optional External Clock */
@@ -147,9 +142,6 @@ struct sci_port {
 	int				rx_fifo_timeout;
 	u16				hscif_tot;
 
-	u8				type;
-	u8				regtype;
-
 	const struct sci_port_ops *ops;
 
 	bool has_rtscts;
diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c
index 538b2f991609f..1c356544a832a 100644
--- a/drivers/tty/serial/sh-sci.c
+++ b/drivers/tty/serial/sh-sci.c
@@ -54,7 +54,6 @@
 #include <asm/platform_early.h>
 #endif
 
-#include "rsci.h"
 #include "serial_mctrl_gpio.h"
 #include "sh-sci.h"
 #include "sh-sci-common.h"
@@ -76,8 +75,6 @@
 
 #define SCI_NPORTS CONFIG_SERIAL_SH_SCI_NR_UARTS
 
-#define SCI_PUBLIC_PORT_ID(port) (((port) & BIT(7)) ? PORT_GENERIC : (port))
-
 static struct sci_port sci_ports[SCI_NPORTS];
 static unsigned long sci_ports_in_use;
 static struct uart_driver sci_uart_driver;
@@ -551,7 +548,6 @@ void sci_port_enable(struct sci_port *sci_port)
 	}
 	sci_port->port.uartclk = sci_port->clk_rates[SCI_FCK];
 }
-EXPORT_SYMBOL_NS_GPL(sci_port_enable, "SH_SCI");
 
 void sci_port_disable(struct sci_port *sci_port)
 {
@@ -565,7 +561,6 @@ void sci_port_disable(struct sci_port *sci_port)
 
 	pm_runtime_put_sync(sci_port->port.dev);
 }
-EXPORT_SYMBOL_NS_GPL(sci_port_disable, "SH_SCI");
 
 static inline unsigned long port_rx_irq_mask(struct uart_port *port)
 {
@@ -585,7 +580,7 @@ static void sci_start_tx(struct uart_port *port)
 	unsigned short ctrl;
 
 #ifdef CONFIG_SERIAL_SH_SCI_DMA
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB) {
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {
 		u16 new, scr = sci_serial_in(port, SCSCR);
 		if (s->chan_tx)
 			new = scr | SCSCR_TDRQE;
@@ -597,7 +592,7 @@ static void sci_start_tx(struct uart_port *port)
 
 	if (s->chan_tx && !kfifo_is_empty(&port->state->port.xmit_fifo) &&
 	    dma_submit_error(s->cookie_tx)) {
-		if (s->regtype == SCIx_RZ_SCIFA_REGTYPE)
+		if (s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE)
 			/* Switch irq from SCIF to DMA */
 			disable_irq_nosync(s->irqs[SCIx_TXI_IRQ]);
 
@@ -606,8 +601,8 @@ static void sci_start_tx(struct uart_port *port)
 	}
 #endif
 
-	if (!s->chan_tx || s->regtype == SCIx_RZ_SCIFA_REGTYPE ||
-	    s->type == PORT_SCIFA || s->type == PORT_SCIFB) {
+	if (!s->chan_tx || s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE ||
+	    port->type == PORT_SCIFA || port->type == PORT_SCIFB) {
 		/* Set TIE (Transmit Interrupt Enable) bit in SCSCR */
 		ctrl = sci_serial_in(port, SCSCR);
 
@@ -616,7 +611,7 @@ static void sci_start_tx(struct uart_port *port)
 		 * (transmit interrupt enable) or in the same instruction to start
 		 * the transmit process.
 		 */
-		if (s->type == PORT_SCI)
+		if (port->type == PORT_SCI)
 			ctrl |= SCSCR_TE;
 
 		sci_serial_out(port, SCSCR, ctrl | SCSCR_TIE);
@@ -625,13 +620,12 @@ static void sci_start_tx(struct uart_port *port)
 
 static void sci_stop_tx(struct uart_port *port)
 {
-	struct sci_port *s = to_sci_port(port);
 	unsigned short ctrl;
 
 	/* Clear TIE (Transmit Interrupt Enable) bit in SCSCR */
 	ctrl = sci_serial_in(port, SCSCR);
 
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB)
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB)
 		ctrl &= ~SCSCR_TDRQE;
 
 	ctrl &= ~SCSCR_TIE;
@@ -639,22 +633,21 @@ static void sci_stop_tx(struct uart_port *port)
 	sci_serial_out(port, SCSCR, ctrl);
 
 #ifdef CONFIG_SERIAL_SH_SCI_DMA
-	if (s->chan_tx &&
-	    !dma_submit_error(s->cookie_tx)) {
-		dmaengine_terminate_async(s->chan_tx);
-		s->cookie_tx = -EINVAL;
+	if (to_sci_port(port)->chan_tx &&
+	    !dma_submit_error(to_sci_port(port)->cookie_tx)) {
+		dmaengine_terminate_async(to_sci_port(port)->chan_tx);
+		to_sci_port(port)->cookie_tx = -EINVAL;
 	}
 #endif
 }
 
 static void sci_start_rx(struct uart_port *port)
 {
-	struct sci_port *s = to_sci_port(port);
 	unsigned short ctrl;
 
 	ctrl = sci_serial_in(port, SCSCR) | port_rx_irq_mask(port);
 
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB)
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB)
 		ctrl &= ~SCSCR_RDRQE;
 
 	sci_serial_out(port, SCSCR, ctrl);
@@ -662,12 +655,11 @@ static void sci_start_rx(struct uart_port *port)
 
 static void sci_stop_rx(struct uart_port *port)
 {
-	struct sci_port *s = to_sci_port(port);
 	unsigned short ctrl;
 
 	ctrl = sci_serial_in(port, SCSCR);
 
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB)
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB)
 		ctrl &= ~SCSCR_RDRQE;
 
 	ctrl &= ~port_rx_irq_mask(port);
@@ -677,12 +669,10 @@ static void sci_stop_rx(struct uart_port *port)
 
 static void sci_clear_SCxSR(struct uart_port *port, unsigned int mask)
 {
-	struct sci_port *s = to_sci_port(port);
-
-	if (s->type == PORT_SCI) {
+	if (port->type == PORT_SCI) {
 		/* Just store the mask */
 		sci_serial_out(port, SCxSR, mask);
-	} else if (s->params->overrun_mask == SCIFA_ORER) {
+	} else if (to_sci_port(port)->params->overrun_mask == SCIFA_ORER) {
 		/* SCIFA/SCIFB and SCIF on SH7705/SH7720/SH7721 */
 		/* Only clear the status bits we want to clear */
 		sci_serial_out(port, SCxSR, sci_serial_in(port, SCxSR) & mask);
@@ -752,13 +742,13 @@ static void sci_init_pins(struct uart_port *port, unsigned int cflag)
 		return;
 	}
 
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB) {
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {
 		u16 data = sci_serial_in(port, SCPDR);
 		u16 ctrl = sci_serial_in(port, SCPCR);
 
 		/* Enable RXD and TXD pin functions */
 		ctrl &= ~(SCPCR_RXDC | SCPCR_TXDC);
-		if (s->has_rtscts) {
+		if (to_sci_port(port)->has_rtscts) {
 			/* RTS# is output, active low, unless autorts */
 			if (!(port->mctrl & TIOCM_RTS)) {
 				ctrl |= SCPCR_RTSC;
@@ -775,7 +765,7 @@ static void sci_init_pins(struct uart_port *port, unsigned int cflag)
 		}
 		sci_serial_out(port, SCPDR, data);
 		sci_serial_out(port, SCPCR, ctrl);
-	} else if (sci_getreg(port, SCSPTR)->size && s->regtype != SCIx_RZV2H_SCIF_REGTYPE) {
+	} else if (sci_getreg(port, SCSPTR)->size && s->cfg->regtype != SCIx_RZV2H_SCIF_REGTYPE) {
 		u16 status = sci_serial_in(port, SCSPTR);
 
 		/* RTS# is always output; and active low, unless autorts */
@@ -862,8 +852,8 @@ static void sci_transmit_chars(struct uart_port *port)
 			c = port->x_char;
 			port->x_char = 0;
 		} else if (stopped || !kfifo_get(&tport->xmit_fifo, &c)) {
-			if (s->type == PORT_SCI &&
-			    kfifo_is_empty(&tport->xmit_fifo)) {
+			if (port->type == PORT_SCI &&
+				   kfifo_is_empty(&tport->xmit_fifo)) {
 				ctrl = sci_serial_in(port, SCSCR);
 				ctrl &= ~SCSCR_TE;
 				sci_serial_out(port, SCSCR, ctrl);
@@ -883,7 +873,7 @@ static void sci_transmit_chars(struct uart_port *port)
 	if (kfifo_len(&tport->xmit_fifo) < WAKEUP_CHARS)
 		uart_write_wakeup(port);
 	if (kfifo_is_empty(&tport->xmit_fifo)) {
-		if (s->type == PORT_SCI) {
+		if (port->type == PORT_SCI) {
 			ctrl = sci_serial_in(port, SCSCR);
 			ctrl &= ~SCSCR_TIE;
 			ctrl |= SCSCR_TEIE;
@@ -914,7 +904,7 @@ static void sci_receive_chars(struct uart_port *port)
 		if (count == 0)
 			break;
 
-		if (s->type == PORT_SCI) {
+		if (port->type == PORT_SCI) {
 			char c = sci_serial_in(port, SCxRDR);
 			if (uart_handle_sysrq_char(port, c))
 				count = 0;
@@ -924,8 +914,8 @@ static void sci_receive_chars(struct uart_port *port)
 			for (i = 0; i < count; i++) {
 				char c;
 
-				if (s->type == PORT_SCIF ||
-				    s->type == PORT_HSCIF) {
+				if (port->type == PORT_SCIF ||
+				    port->type == PORT_HSCIF) {
 					status = sci_serial_in(port, SCxSR);
 					c = sci_serial_in(port, SCxRDR);
 				} else {
@@ -1062,7 +1052,6 @@ static int sci_handle_breaks(struct uart_port *port)
 
 static int scif_set_rtrg(struct uart_port *port, int rx_trig)
 {
-	struct sci_port *s = to_sci_port(port);
 	unsigned int bits;
 
 	if (rx_trig >= port->fifosize)
@@ -1076,7 +1065,7 @@ static int scif_set_rtrg(struct uart_port *port, int rx_trig)
 		return rx_trig;
 	}
 
-	switch (s->type) {
+	switch (port->type) {
 	case PORT_SCIF:
 		if (rx_trig < 4) {
 			bits = 0;
@@ -1161,7 +1150,7 @@ static ssize_t rx_fifo_trigger_store(struct device *dev,
 		return ret;
 
 	sci->rx_trigger = sci->ops->set_rtrg(port, r);
-	if (sci->type == PORT_SCIFA || sci->type == PORT_SCIFB)
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB)
 		sci->ops->set_rtrg(port, 1);
 
 	return count;
@@ -1177,7 +1166,7 @@ static ssize_t rx_fifo_timeout_show(struct device *dev,
 	struct sci_port *sci = to_sci_port(port);
 	int v;
 
-	if (sci->type == PORT_HSCIF)
+	if (port->type == PORT_HSCIF)
 		v = sci->hscif_tot >> HSSCR_TOT_SHIFT;
 	else
 		v = sci->rx_fifo_timeout;
@@ -1199,7 +1188,7 @@ static ssize_t rx_fifo_timeout_store(struct device *dev,
 	if (ret)
 		return ret;
 
-	if (sci->type == PORT_HSCIF) {
+	if (port->type == PORT_HSCIF) {
 		if (r < 0 || r > 3)
 			return -EINVAL;
 		sci->hscif_tot = r << HSSCR_TOT_SHIFT;
@@ -1240,11 +1229,11 @@ static void sci_dma_tx_complete(void *arg)
 		schedule_work(&s->work_tx);
 	} else {
 		s->cookie_tx = -EINVAL;
-		if (s->type == PORT_SCIFA || s->type == PORT_SCIFB ||
-		    s->regtype == SCIx_RZ_SCIFA_REGTYPE) {
+		if (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||
+		    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {
 			u16 ctrl = sci_serial_in(port, SCSCR);
 			sci_serial_out(port, SCSCR, ctrl & ~SCSCR_TIE);
-			if (s->regtype == SCIx_RZ_SCIFA_REGTYPE) {
+			if (s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {
 				/* Switch irq from DMA to SCIF */
 				dmaengine_pause(s->chan_tx_saved);
 				enable_irq(s->irqs[SCIx_TXI_IRQ]);
@@ -1326,10 +1315,10 @@ static void sci_dma_rx_reenable_irq(struct sci_port *s)
 
 	/* Direct new serial port interrupts back to CPU */
 	scr = sci_serial_in(port, SCSCR);
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB ||
-	    s->regtype == SCIx_RZ_SCIFA_REGTYPE) {
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||
+	    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {
 		enable_irq(s->irqs[SCIx_RXI_IRQ]);
-		if (s->regtype == SCIx_RZ_SCIFA_REGTYPE)
+		if (s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE)
 			s->ops->set_rtrg(port, s->rx_trigger);
 		else
 			scr &= ~SCSCR_RDRQE;
@@ -1569,8 +1558,8 @@ static enum hrtimer_restart sci_dma_rx_timer_fn(struct hrtimer *t)
 			tty_flip_buffer_push(&port->state->port);
 	}
 
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB ||
-	    s->regtype == SCIx_RZ_SCIFA_REGTYPE)
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||
+	    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE)
 		sci_dma_rx_submit(s, true);
 
 	sci_dma_rx_reenable_irq(s);
@@ -1693,8 +1682,8 @@ static void sci_request_dma(struct uart_port *port)
 
 		s->chan_rx_saved = s->chan_rx = chan;
 
-		if (s->type == PORT_SCIFA || s->type == PORT_SCIFB ||
-		    s->regtype == SCIx_RZ_SCIFA_REGTYPE)
+		if (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||
+		    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE)
 			sci_dma_rx_submit(s, false);
 	}
 }
@@ -1764,10 +1753,10 @@ static irqreturn_t sci_rx_interrupt(int irq, void *ptr)
 		u16 ssr = sci_serial_in(port, SCxSR);
 
 		/* Disable future Rx interrupts */
-		if (s->type == PORT_SCIFA || s->type == PORT_SCIFB ||
-		    s->regtype == SCIx_RZ_SCIFA_REGTYPE) {
+		if (port->type == PORT_SCIFA || port->type == PORT_SCIFB ||
+		    s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {
 			disable_irq_nosync(s->irqs[SCIx_RXI_IRQ]);
-			if (s->regtype == SCIx_RZ_SCIFA_REGTYPE) {
+			if (s->cfg->regtype == SCIx_RZ_SCIFA_REGTYPE) {
 				s->ops->set_rtrg(port, 1);
 				scr |= SCSCR_RIE;
 			} else {
@@ -1831,7 +1820,7 @@ static irqreturn_t sci_tx_end_interrupt(int irq, void *ptr)
 	unsigned long flags;
 	u32 ctrl;
 
-	if (s->type != PORT_SCI && s->type != SCI_PORT_RSCI)
+	if (port->type != PORT_SCI)
 		return sci_tx_interrupt(irq, ptr);
 
 	uart_port_lock_irqsave(port, &flags);
@@ -1878,7 +1867,7 @@ static irqreturn_t sci_er_interrupt(int irq, void *ptr)
 	}
 
 	/* Handle errors */
-	if (s->type == PORT_SCI) {
+	if (port->type == PORT_SCI) {
 		if (sci_handle_errors(port)) {
 			/* discard character in rx buffer */
 			sci_serial_in(port, SCxSR);
@@ -2102,9 +2091,7 @@ static unsigned int sci_tx_empty(struct uart_port *port)
 
 static void sci_set_rts(struct uart_port *port, bool state)
 {
-	struct sci_port *s = to_sci_port(port);
-
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB) {
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {
 		u16 data = sci_serial_in(port, SCPDR);
 
 		/* Active low */
@@ -2131,9 +2118,7 @@ static void sci_set_rts(struct uart_port *port, bool state)
 
 static bool sci_get_cts(struct uart_port *port)
 {
-	struct sci_port *s = to_sci_port(port);
-
-	if (s->type == PORT_SCIFA || s->type == PORT_SCIFB) {
+	if (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {
 		/* Active low */
 		return !(sci_serial_in(port, SCPDR) & SCPDR_CTSD);
 	} else if (sci_getreg(port, SCSPTR)->size) {
@@ -2179,21 +2164,21 @@ static void sci_set_mctrl(struct uart_port *port, unsigned int mctrl)
 
 	if (!(mctrl & TIOCM_RTS)) {
 		/* Disable Auto RTS */
-		if (s->regtype != SCIx_RZV2H_SCIF_REGTYPE)
+		if (s->cfg->regtype != SCIx_RZV2H_SCIF_REGTYPE)
 			sci_serial_out(port, SCFCR,
 				       sci_serial_in(port, SCFCR) & ~SCFCR_MCE);
 
 		/* Clear RTS */
 		sci_set_rts(port, 0);
 	} else if (s->autorts) {
-		if (s->type == PORT_SCIFA || s->type == PORT_SCIFB) {
+		if (port->type == PORT_SCIFA || port->type == PORT_SCIFB) {
 			/* Enable RTS# pin function */
 			sci_serial_out(port, SCPCR,
 				sci_serial_in(port, SCPCR) & ~SCPCR_RTSC);
 		}
 
 		/* Enable Auto RTS */
-		if (s->regtype != SCIx_RZV2H_SCIF_REGTYPE)
+		if (s->cfg->regtype != SCIx_RZV2H_SCIF_REGTYPE)
 			sci_serial_out(port, SCFCR,
 				       sci_serial_in(port, SCFCR) | SCFCR_MCE);
 	} else {
@@ -2292,7 +2277,6 @@ int sci_startup(struct uart_port *port)
 
 	return 0;
 }
-EXPORT_SYMBOL_NS_GPL(sci_startup, "SH_SCI");
 
 void sci_shutdown(struct uart_port *port)
 {
@@ -2305,8 +2289,8 @@ void sci_shutdown(struct uart_port *port)
 	mctrl_gpio_disable_ms_sync(to_sci_port(port)->gpios);
 
 	uart_port_lock_irqsave(port, &flags);
-	s->port.ops->stop_rx(port);
-	s->port.ops->stop_tx(port);
+	sci_stop_rx(port);
+	sci_stop_tx(port);
 	s->ops->shutdown_complete(port);
 	uart_port_unlock_irqrestore(port, flags);
 
@@ -2323,7 +2307,6 @@ void sci_shutdown(struct uart_port *port)
 	sci_free_irq(s);
 	sci_free_dma(port);
 }
-EXPORT_SYMBOL_NS_GPL(sci_shutdown, "SH_SCI");
 
 static int sci_sck_calc(struct sci_port *s, unsigned int bps,
 			unsigned int *srr)
@@ -2332,7 +2315,7 @@ static int sci_sck_calc(struct sci_port *s, unsigned int bps,
 	int err, min_err = INT_MAX;
 	unsigned int sr;
 
-	if (s->type != PORT_HSCIF)
+	if (s->port.type != PORT_HSCIF)
 		freq *= 2;
 
 	for_each_sr(sr, s) {
@@ -2359,7 +2342,7 @@ static int sci_brg_calc(struct sci_port *s, unsigned int bps,
 	int err, min_err = INT_MAX;
 	unsigned int sr, dl;
 
-	if (s->type != PORT_HSCIF)
+	if (s->port.type != PORT_HSCIF)
 		freq *= 2;
 
 	for_each_sr(sr, s) {
@@ -2392,7 +2375,7 @@ static int sci_scbrr_calc(struct sci_port *s, unsigned int bps,
 	unsigned int sr, br, prediv, scrate, c;
 	int err, min_err = INT_MAX;
 
-	if (s->type != PORT_HSCIF)
+	if (s->port.type != PORT_HSCIF)
 		freq *= 2;
 
 	/*
@@ -2477,8 +2460,8 @@ static void sci_reset(struct uart_port *port)
 			s->ops->set_rtrg(port, 1);
 			timer_setup(&s->rx_fifo_timer, rx_fifo_timer_fn, 0);
 		} else {
-			if (s->type == PORT_SCIFA ||
-			    s->type == PORT_SCIFB)
+			if (port->type == PORT_SCIFA ||
+			    port->type == PORT_SCIFB)
 				s->ops->set_rtrg(port, 1);
 			else
 				s->ops->set_rtrg(port, s->rx_trigger);
@@ -2538,8 +2521,8 @@ static void sci_set_termios(struct uart_port *port, struct ktermios *termios,
 	 */
 
 	/* Optional Undivided External Clock */
-	if (s->clk_rates[SCI_SCK] && s->type != PORT_SCIFA &&
-	    s->type != PORT_SCIFB) {
+	if (s->clk_rates[SCI_SCK] && port->type != PORT_SCIFA &&
+	    port->type != PORT_SCIFB) {
 		err = sci_sck_calc(s, baud, &srr1);
 		if (abs(err) < abs(min_err)) {
 			best_clk = SCI_SCK;
@@ -2624,7 +2607,7 @@ static void sci_set_termios(struct uart_port *port, struct ktermios *termios,
 		sci_serial_out(port, SEMR, 0);
 
 	if (best_clk >= 0) {
-		if (s->type == PORT_SCIFA || s->type == PORT_SCIFB)
+		if (port->type == PORT_SCIFA || port->type == PORT_SCIFB)
 			switch (srr + 1) {
 			case 5:  smr_val |= SCSMR_SRC_5;  break;
 			case 7:  smr_val |= SCSMR_SRC_7;  break;
@@ -2709,12 +2692,12 @@ static void sci_set_termios(struct uart_port *port, struct ktermios *termios,
 	 * (transmit interrupt enable) or in the same instruction to
 	 * start the transmitting process. So skip setting TE here for SCI.
 	 */
-	if (s->type != PORT_SCI)
+	if (port->type != PORT_SCI)
 		scr_val |= SCSCR_TE;
 	scr_val |= SCSCR_RE | (s->cfg->scscr & ~(SCSCR_CKE1 | SCSCR_CKE0));
 	sci_serial_out(port, SCSCR, scr_val | s->hscif_tot);
 	if ((srr + 1 == 5) &&
-	    (s->type == PORT_SCIFA || s->type == PORT_SCIFB)) {
+	    (port->type == PORT_SCIFA || port->type == PORT_SCIFB)) {
 		/*
 		 * In asynchronous mode, when the sampling rate is 1/5, first
 		 * received data may become invalid on some SCIFA and SCIFB.
@@ -2755,13 +2738,10 @@ void sci_pm(struct uart_port *port, unsigned int state,
 		break;
 	}
 }
-EXPORT_SYMBOL_NS_GPL(sci_pm, "SH_SCI");
 
 static const char *sci_type(struct uart_port *port)
 {
-	struct sci_port *s = to_sci_port(port);
-
-	switch (s->type) {
+	switch (port->type) {
 	case PORT_IRDA:
 		return "irda";
 	case PORT_SCI:
@@ -2818,7 +2798,6 @@ void sci_release_port(struct uart_port *port)
 
 	release_mem_region(port->mapbase, sport->reg_size);
 }
-EXPORT_SYMBOL_NS_GPL(sci_release_port, "SH_SCI");
 
 int sci_request_port(struct uart_port *port)
 {
@@ -2841,17 +2820,16 @@ int sci_request_port(struct uart_port *port)
 
 	return 0;
 }
-EXPORT_SYMBOL_NS_GPL(sci_request_port, "SH_SCI");
 
 void sci_config_port(struct uart_port *port, int flags)
 {
 	if (flags & UART_CONFIG_TYPE) {
 		struct sci_port *sport = to_sci_port(port);
-		port->type = SCI_PUBLIC_PORT_ID(sport->type);
+
+		port->type = sport->cfg->type;
 		sci_request_port(port);
 	}
 }
-EXPORT_SYMBOL_NS_GPL(sci_config_port, "SH_SCI");
 
 int sci_verify_port(struct uart_port *port, struct serial_struct *ser)
 {
@@ -2861,7 +2839,6 @@ int sci_verify_port(struct uart_port *port, struct serial_struct *ser)
 
 	return 0;
 }
-EXPORT_SYMBOL_NS_GPL(sci_verify_port, "SH_SCI");
 
 static void sci_prepare_console_write(struct uart_port *port, u32 ctrl)
 {
@@ -2987,27 +2964,14 @@ static int sci_init_clocks(struct sci_port *sci_port, struct device *dev)
 	struct clk *clk;
 	unsigned int i;
 
-	if (sci_port->type == PORT_HSCIF) {
+	if (sci_port->cfg->type == PORT_HSCIF)
 		clk_names[SCI_SCK] = "hsck";
-	} else if (sci_port->type == SCI_PORT_RSCI) {
-		clk_names[SCI_FCK] = "operation";
-		clk_names[SCI_BRG_INT] = "bus";
-	}
 
 	for (i = 0; i < SCI_NUM_CLKS; i++) {
-		const char *name = clk_names[i];
-
-		clk = devm_clk_get_optional(dev, name);
+		clk = devm_clk_get_optional(dev, clk_names[i]);
 		if (IS_ERR(clk))
 			return PTR_ERR(clk);
 
-		if (!clk && sci_port->type == SCI_PORT_RSCI &&
-		    (i == SCI_FCK || i == SCI_BRG_INT)) {
-			return dev_err_probe(dev, -ENODEV,
-					     "failed to get %s\n",
-					     name);
-		}
-
 		if (!clk && i == SCI_FCK) {
 			/*
 			 * Not all SH platforms declare a clock lookup entry
@@ -3018,13 +2982,13 @@ static int sci_init_clocks(struct sci_port *sci_port, struct device *dev)
 			if (IS_ERR(clk))
 				return dev_err_probe(dev, PTR_ERR(clk),
 						     "failed to get %s\n",
-						     name);
+						     clk_names[i]);
 		}
 
 		if (!clk)
-			dev_dbg(dev, "failed to get %s\n", name);
+			dev_dbg(dev, "failed to get %s\n", clk_names[i]);
 		else
-			dev_dbg(dev, "clk %s is %pC rate %lu\n", name,
+			dev_dbg(dev, "clk %s is %pC rate %lu\n", clk_names[i],
 				clk, clk_get_rate(clk));
 		sci_port->clks[i] = clk;
 	}
@@ -3086,9 +3050,6 @@ static int sci_init_single(struct platform_device *dev,
 
 	sci_port->cfg	= p;
 
-	sci_port->type	= p->type;
-	sci_port->regtype = p->regtype;
-
 	port->iotype	= UPIO_MEM;
 	port->line	= index;
 	port->has_sysrq = IS_ENABLED(CONFIG_SERIAL_SH_SCI_CONSOLE);
@@ -3108,10 +3069,10 @@ static int sci_init_single(struct platform_device *dev,
 	}
 
 	/*
-	 * The fourth interrupt on SCI and RSCI port is transmit end interrupt, so
+	 * The fourth interrupt on SCI port is transmit end interrupt, so
 	 * shuffle the interrupts.
 	 */
-	if (p->type == PORT_SCI || p->type == SCI_PORT_RSCI)
+	if (p->type == PORT_SCI)
 		swap(sci_port->irqs[SCIx_BRI_IRQ], sci_port->irqs[SCIx_TEI_IRQ]);
 
 	/* The SCI generates several interrupts. They can be muxed together or
@@ -3145,9 +3106,6 @@ static int sci_init_single(struct platform_device *dev,
 		else
 			sci_port->rx_trigger = 8;
 		break;
-	case SCI_PORT_RSCI:
-		sci_port->rx_trigger = 15;
-		break;
 	default:
 		sci_port->rx_trigger = 1;
 		break;
@@ -3170,11 +3128,11 @@ static int sci_init_single(struct platform_device *dev,
 			return ret;
 	}
 
-	port->type		= SCI_PUBLIC_PORT_ID(p->type);
+	port->type		= p->type;
 	port->flags		= UPF_FIXED_PORT | UPF_BOOT_AUTOCONF | p->flags;
 	port->fifosize		= sci_port->params->fifosize;
 
-	if (p->type == PORT_SCI && !dev->dev.of_node) {
+	if (port->type == PORT_SCI && !dev->dev.of_node) {
 		if (sci_port->reg_size >= 0x20)
 			port->regshift = 2;
 		else
@@ -3364,16 +3322,15 @@ static struct uart_driver sci_uart_driver = {
 
 static void sci_remove(struct platform_device *dev)
 {
-	struct sci_port *s = platform_get_drvdata(dev);
-	unsigned int type = s->type;	/* uart_remove_... clears it */
+	struct sci_port *port = platform_get_drvdata(dev);
+	unsigned int type = port->port.type;	/* uart_remove_... clears it */
 
-	sci_ports_in_use &= ~BIT(s->port.line);
-	uart_remove_one_port(&sci_uart_driver, &s->port);
+	sci_ports_in_use &= ~BIT(port->port.line);
+	uart_remove_one_port(&sci_uart_driver, &port->port);
 
-	if (s->port.fifosize > 1)
+	if (port->port.fifosize > 1)
 		device_remove_file(&dev->dev, &dev_attr_rx_fifo_trigger);
-	if (type == PORT_SCIFA || type == PORT_SCIFB || type == PORT_HSCIF ||
-	    type == SCI_PORT_RSCI)
+	if (type == PORT_SCIFA || type == PORT_SCIFB || type == PORT_HSCIF)
 		device_remove_file(&dev->dev, &dev_attr_rx_fifo_timeout);
 }
 
@@ -3467,12 +3424,6 @@ static const struct of_device_id of_sci_match[] __maybe_unused = {
 		.compatible = "renesas,scif-r9a09g057",
 		.data = &of_sci_scif_rzv2h,
 	},
-#ifdef CONFIG_SERIAL_RSCI
-	{
-		.compatible = "renesas,r9a09g077-rsci",
-		.data = &of_sci_rsci_data,
-	},
-#endif	/* CONFIG_SERIAL_RSCI */
 	/* Family-specific types */
 	{
 		.compatible = "renesas,rcar-gen1-scif",
@@ -3486,9 +3437,6 @@ static const struct of_device_id of_sci_match[] __maybe_unused = {
 	}, {
 		.compatible = "renesas,rcar-gen4-scif",
 		.data = &of_sci_rcar_scif
-	}, {
-		.compatible = "renesas,rcar-gen5-scif",
-		.data = &of_sci_rcar_scif
 	},
 	/* Generic types */
 	{
@@ -3734,8 +3682,8 @@ static int sci_probe(struct platform_device *dev)
 		if (ret)
 			return ret;
 	}
-	if (sp->type == PORT_SCIFA || sp->type == PORT_SCIFB ||
-	    sp->type == PORT_HSCIF || sp->type == SCI_PORT_RSCI) {
+	if (sp->port.type == PORT_SCIFA || sp->port.type == PORT_SCIFB ||
+	    sp->port.type == PORT_HSCIF) {
 		ret = device_create_file(&dev->dev, &dev_attr_rx_fifo_timeout);
 		if (ret) {
 			if (sp->port.fifosize > 1) {
@@ -3754,7 +3702,7 @@ static int sci_probe(struct platform_device *dev)
 	return 0;
 }
 
-static int sci_suspend(struct device *dev)
+static __maybe_unused int sci_suspend(struct device *dev)
 {
 	struct sci_port *sport = dev_get_drvdata(dev);
 
@@ -3772,7 +3720,7 @@ static int sci_suspend(struct device *dev)
 	return 0;
 }
 
-static int sci_resume(struct device *dev)
+static __maybe_unused int sci_resume(struct device *dev)
 {
 	struct sci_port *sport = dev_get_drvdata(dev);
 
@@ -3793,14 +3741,14 @@ static int sci_resume(struct device *dev)
 	return 0;
 }
 
-static DEFINE_SIMPLE_DEV_PM_OPS(sci_dev_pm_ops, sci_suspend, sci_resume);
+static SIMPLE_DEV_PM_OPS(sci_dev_pm_ops, sci_suspend, sci_resume);
 
 static struct platform_driver sci_driver = {
 	.probe		= sci_probe,
 	.remove		= sci_remove,
 	.driver		= {
 		.name	= "sh-sci",
-		.pm	= pm_sleep_ptr(&sci_dev_pm_ops),
+		.pm	= &sci_dev_pm_ops,
 		.of_match_table = of_match_ptr(of_sci_match),
 	},
 };
@@ -3851,11 +3799,8 @@ int __init scix_early_console_setup(struct earlycon_device *device,
 	if (!device->port.membase)
 		return -ENODEV;
 
-	device->port.type = SCI_PUBLIC_PORT_ID(data->type);
-
+	device->port.type = data->type;
 	sci_ports[0].port = device->port;
-	sci_ports[0].type = data->type;
-	sci_ports[0].regtype = data->regtype;
 
 	port_cfg.type = data->type;
 	port_cfg.regtype = data->regtype;
diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c
index 67271fc0b223b..79f0ff94ce00d 100644
--- a/drivers/tty/tty_buffer.c
+++ b/drivers/tty/tty_buffer.c
@@ -499,7 +499,8 @@ static void flush_to_ldisc(struct work_struct *work)
 		if (!rcvd)
 			break;
 
-		cond_resched();
+		if (need_resched())
+			cond_resched();
 	}
 
 	mutex_unlock(&buf->lock);
diff --git a/drivers/tty/tty_port.c b/drivers/tty/tty_port.c
index 5b4d5fb99a593..4af1fbf73f51c 100644
--- a/drivers/tty/tty_port.c
+++ b/drivers/tty/tty_port.c
@@ -391,19 +391,20 @@ void tty_port_hangup(struct tty_port *port)
 }
 EXPORT_SYMBOL(tty_port_hangup);
 
-void __tty_port_tty_hangup(struct tty_port *port, bool check_clocal, bool async)
+/**
+ * tty_port_tty_hangup - helper to hang up a tty
+ * @port: tty port
+ * @check_clocal: hang only ttys with %CLOCAL unset?
+ */
+void tty_port_tty_hangup(struct tty_port *port, bool check_clocal)
 {
 	struct tty_struct *tty = tty_port_tty_get(port);
 
-	if (tty && (!check_clocal || !C_CLOCAL(tty))) {
-		if (async)
-			tty_hangup(tty);
-		else
-			tty_vhangup(tty);
-	}
+	if (tty && (!check_clocal || !C_CLOCAL(tty)))
+		tty_hangup(tty);
 	tty_kref_put(tty);
 }
-EXPORT_SYMBOL_GPL(__tty_port_tty_hangup);
+EXPORT_SYMBOL_GPL(tty_port_tty_hangup);
 
 /**
  * tty_port_tty_wakeup - helper to wake up a tty
diff --git a/drivers/tty/vt/defkeymap.c_shipped b/drivers/tty/vt/defkeymap.c_shipped
index 6af7bf8d5460c..0c043e4f292e8 100644
--- a/drivers/tty/vt/defkeymap.c_shipped
+++ b/drivers/tty/vt/defkeymap.c_shipped
@@ -23,22 +23,6 @@ unsigned short plain_map[NR_KEYS] = {
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 static unsigned short shift_map[NR_KEYS] = {
@@ -58,22 +42,6 @@ static unsigned short shift_map[NR_KEYS] = {
 	0xf20b,	0xf601,	0xf602,	0xf117,	0xf600,	0xf20a,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 static unsigned short altgr_map[NR_KEYS] = {
@@ -93,22 +61,6 @@ static unsigned short altgr_map[NR_KEYS] = {
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 static unsigned short ctrl_map[NR_KEYS] = {
@@ -128,22 +80,6 @@ static unsigned short ctrl_map[NR_KEYS] = {
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 static unsigned short shift_ctrl_map[NR_KEYS] = {
@@ -163,22 +99,6 @@ static unsigned short shift_ctrl_map[NR_KEYS] = {
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 static unsigned short alt_map[NR_KEYS] = {
@@ -198,22 +118,6 @@ static unsigned short alt_map[NR_KEYS] = {
 	0xf118,	0xf210,	0xf211,	0xf117,	0xf600,	0xf119,	0xf115,	0xf116,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 static unsigned short ctrl_alt_map[NR_KEYS] = {
@@ -233,22 +137,6 @@ static unsigned short ctrl_alt_map[NR_KEYS] = {
 	0xf118,	0xf601,	0xf602,	0xf117,	0xf600,	0xf119,	0xf115,	0xf20c,
 	0xf11a,	0xf10c,	0xf10d,	0xf11b,	0xf11c,	0xf110,	0xf311,	0xf11d,
 	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
-	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,	0xf200,
 };
 
 unsigned short *key_maps[MAX_NR_KEYMAPS] = {
diff --git a/drivers/tty/vt/keyboard.c b/drivers/tty/vt/keyboard.c
index ee1d9c448c7eb..dc585079c2fb8 100644
--- a/drivers/tty/vt/keyboard.c
+++ b/drivers/tty/vt/keyboard.c
@@ -1487,7 +1487,7 @@ static void kbd_keycode(unsigned int keycode, int down, bool hw_raw)
 		rc = atomic_notifier_call_chain(&keyboard_notifier_list,
 						KBD_UNICODE, &param);
 		if (rc != NOTIFY_STOP)
-			if (down && !(raw_mode || kbd->kbdmode == VC_OFF))
+			if (down && !raw_mode)
 				k_unicode(vc, keysym, !down);
 		return;
 	}
diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c
index f9171fbedf5ca..c2ecfa3c83496 100644
--- a/drivers/usb/class/cdc-acm.c
+++ b/drivers/usb/class/cdc-acm.c
@@ -1571,6 +1571,7 @@ static int acm_probe(struct usb_interface *intf,
 static void acm_disconnect(struct usb_interface *intf)
 {
 	struct acm *acm = usb_get_intfdata(intf);
+	struct tty_struct *tty;
 	int i;
 
 	/* sibling interface is already cleaning up */
@@ -1597,7 +1598,11 @@ static void acm_disconnect(struct usb_interface *intf)
 	usb_set_intfdata(acm->data, NULL);
 	mutex_unlock(&acm->mutex);
 
-	tty_port_tty_vhangup(&acm->port);
+	tty = tty_port_tty_get(&acm->port);
+	if (tty) {
+		tty_vhangup(tty);
+		tty_kref_put(tty);
+	}
 
 	cancel_delayed_work_sync(&acm->dwork);
 
diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c
index c78ff40b1e5f8..7266558d823ac 100644
--- a/drivers/usb/serial/usb-serial.c
+++ b/drivers/usb/serial/usb-serial.c
@@ -1176,6 +1176,7 @@ static void usb_serial_disconnect(struct usb_interface *interface)
 	struct usb_serial *serial = usb_get_intfdata(interface);
 	struct device *dev = &interface->dev;
 	struct usb_serial_port *port;
+	struct tty_struct *tty;
 
 	/* sibling interface is cleaning up */
 	if (!serial)
@@ -1190,7 +1191,11 @@ static void usb_serial_disconnect(struct usb_interface *interface)
 
 	for (i = 0; i < serial->num_ports; ++i) {
 		port = serial->port[i];
-		tty_port_tty_vhangup(&port->port);
+		tty = tty_port_tty_get(&port->port);
+		if (tty) {
+			tty_vhangup(tty);
+			tty_kref_put(tty);
+		}
 		usb_serial_port_poison_urbs(port);
 		wake_up_interruptible(&port->port.delta_msr_wait);
 		cancel_work_sync(&port->work);
diff --git a/include/linux/serial_8250.h b/include/linux/serial_8250.h
index 01efdce0fda07..144de7a7948de 100644
--- a/include/linux/serial_8250.h
+++ b/include/linux/serial_8250.h
@@ -46,8 +46,8 @@ struct plat_serial8250_port {
 	unsigned int	type;		/* If UPF_FIXED_TYPE */
 	upf_t		flags;		/* UPF_* flags */
 	u16		bugs;		/* port bugs */
-	u32		(*serial_in)(struct uart_port *, unsigned int offset);
-	void		(*serial_out)(struct uart_port *, unsigned int offset, u32 val);
+	unsigned int	(*serial_in)(struct uart_port *, int);
+	void		(*serial_out)(struct uart_port *, int, int);
 	u32		(*dl_read)(struct uart_8250_port *up);
 	void		(*dl_write)(struct uart_8250_port *up, u32 value);
 	void		(*set_termios)(struct uart_port *,
diff --git a/include/linux/serial_core.h b/include/linux/serial_core.h
index 84b4648ead7e0..914b5e97e0564 100644
--- a/include/linux/serial_core.h
+++ b/include/linux/serial_core.h
@@ -443,8 +443,8 @@ struct uart_port {
 	spinlock_t		lock;			/* port lock */
 	unsigned long		iobase;			/* in/out[bwl] */
 	unsigned char __iomem	*membase;		/* read/write[bwl] */
-	u32			(*serial_in)(struct uart_port *, unsigned int offset);
-	void			(*serial_out)(struct uart_port *, unsigned int offset, u32 val);
+	unsigned int		(*serial_in)(struct uart_port *, int);
+	void			(*serial_out)(struct uart_port *, int, int);
 	void			(*set_termios)(struct uart_port *,
 				               struct ktermios *new,
 				               const struct ktermios *old);
@@ -1101,6 +1101,8 @@ static inline bool uart_console_registered(struct uart_port *port)
 	return uart_console(port) && console_is_registered(port->cons);
 }
 
+struct uart_port *uart_get_console(struct uart_port *ports, int nr,
+				   struct console *c);
 int uart_parse_earlycon(char *p, enum uart_iotype *iotype,
 			resource_size_t *addr, char **options);
 void uart_parse_options(const char *options, int *baud, int *parity, int *bits,
diff --git a/include/linux/tty_port.h b/include/linux/tty_port.h
index 332ddb93603ec..08f89a5983662 100644
--- a/include/linux/tty_port.h
+++ b/include/linux/tty_port.h
@@ -232,7 +232,7 @@ bool tty_port_carrier_raised(struct tty_port *port);
 void tty_port_raise_dtr_rts(struct tty_port *port);
 void tty_port_lower_dtr_rts(struct tty_port *port);
 void tty_port_hangup(struct tty_port *port);
-void __tty_port_tty_hangup(struct tty_port *port, bool check_clocal, bool async);
+void tty_port_tty_hangup(struct tty_port *port, bool check_clocal);
 void tty_port_tty_wakeup(struct tty_port *port);
 int tty_port_block_til_ready(struct tty_port *port, struct tty_struct *tty,
 		struct file *filp);
@@ -251,23 +251,4 @@ static inline int tty_port_users(struct tty_port *port)
 	return port->count + port->blocked_open;
 }
 
-/**
- * tty_port_tty_hangup - helper to hang up a tty asynchronously
- * @port: tty port
- * @check_clocal: hang only ttys with %CLOCAL unset?
- */
-static inline void tty_port_tty_hangup(struct tty_port *port, bool check_clocal)
-{
-	__tty_port_tty_hangup(port, check_clocal, true);
-}
-
-/**
- * tty_port_tty_vhangup - helper to hang up a tty synchronously
- * @port: tty port
- */
-static inline void tty_port_tty_vhangup(struct tty_port *port)
-{
-	__tty_port_tty_hangup(port, false, false);
-}
-
 #endif
diff --git a/net/bluetooth/rfcomm/tty.c b/net/bluetooth/rfcomm/tty.c
index 827dfbe660856..21a5b5535ebce 100644
--- a/net/bluetooth/rfcomm/tty.c
+++ b/net/bluetooth/rfcomm/tty.c
@@ -438,6 +438,7 @@ static int __rfcomm_release_dev(void __user *arg)
 {
 	struct rfcomm_dev_req req;
 	struct rfcomm_dev *dev;
+	struct tty_struct *tty;
 
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
@@ -463,7 +464,11 @@ static int __rfcomm_release_dev(void __user *arg)
 		rfcomm_dlc_close(dev->dlc, 0);
 
 	/* Shut down TTY synchronously before freeing rfcomm_dev */
-	tty_port_tty_vhangup(&dev->port);
+	tty = tty_port_tty_get(&dev->port);
+	if (tty) {
+		tty_vhangup(tty);
+		tty_kref_put(tty);
+	}
 
 	if (!test_bit(RFCOMM_TTY_OWNED, &dev->status))
 		tty_port_put(&dev->port);
